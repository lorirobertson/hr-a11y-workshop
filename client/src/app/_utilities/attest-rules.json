{
    "rules": [
      {
        "id": "accesskeys",
        "selector": "[accesskey]",
        "excludeHidden": false,
        "enabled": false,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "accesskeys"
        ],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "accesskey attribute value must be unique",
          "description": "Ensures every accesskey attribute value is unique"
        }
      },
      {
        "id": "area-alt",
        "selector": "map area[href]",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "non-empty-alt",
          "non-empty-title",
          "aria-label",
          "aria-labelledby"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.text-alternatives",
          "wcag2a",
          "wcag111",
          "section508",
          "section508.22.a"
        ],
        "preload": false,
        "metadata": {
          "help": "Active <area> elements must have alternate text",
          "description": "Ensures <area> elements of image maps have alternate text",
          "mapping": {
            "ruleId": "010109-A",
            "SC": "1.1.1",
            "weight": 3,
            "description": "Missing text equivalent for area."
          }
        }
      },
      {
        "id": "aria-allowed-attr",
        "selector": "*",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "aria-allowed-attr"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.aria",
          "wcag2a",
          "wcag412"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var role = node.getAttribute('role');\n        if (!role) {\n          role = axe.commons.aria.implicitRole(node);\n        }\n        var allowed = axe.commons.aria.allowedAttr(role);\n        if (role && allowed) {\n          var aria = /^aria-/;\n          if (node.hasAttributes()) {\n            var attrs = node.attributes;\n            for (var i = 0, l = attrs.length; i < l; i++) {\n              if (aria.test(attrs[i].name)) {\n                return true;\n              }\n            }\n          }\n        }\n        return false;\n      }",
        "metadata": {
          "help": "Elements must only use allowed ARIA attributes",
          "description": "Ensures ARIA attributes are allowed for an element's role",
          "mapping": {
            "ruleId": "ARIA_ATTRIBUTE_VALID",
            "SC": "4.1.1",
            "weight": 0,
            "description": "Checks all attributes that start with 'aria-' to ensure that they are all official WAI-ARIA attributes"
          }
        }
      },
      {
        "id": "aria-allowed-role",
        "selector": "[role]",
        "excludeHidden": false,
        "enabled": false,
        "pageLevel": false,
        "any": [
          {
            "options": {
              "allowImplicit": true,
              "ignoredTags": []
            },
            "id": "aria-allowed-role"
          }
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return axe.commons.aria.getRole(node, {\n          noImplicit: true,\n          dpub: true,\n          fallback: true\n        }) !== null;\n      }",
        "metadata": {
          "help": "ARIA role must be appropriate for the element",
          "description": "Ensures role attribute has an appropriate value for the element"
        }
      },
      {
        "id": "aria-dpub-role-fallback",
        "selector": "[role]",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [
          "implicit-role-fallback"
        ],
        "none": [],
        "tags": [
          "cat.aria",
          "wcag2a",
          "wcag131"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var role = node.getAttribute('role');\n        return [ 'doc-backlink', 'doc-biblioentry', 'doc-biblioref', 'doc-cover', 'doc-endnote', 'doc-glossref', 'doc-noteref' ].includes(role);\n      }",
        "metadata": {
          "help": "Unsupported DPUB ARIA roles should be used on elements with implicit fallback roles",
          "description": "Ensures unsupported DPUB roles are only used on elements with implicit fallback roles"
        }
      },
      {
        "id": "aria-hidden-body",
        "selector": "body",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "aria-hidden-body"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.aria",
          "wcag2a",
          "wcag412"
        ],
        "preload": false,
        "metadata": {
          "help": "aria-hidden='true' must not be present on the document body",
          "description": "Ensures aria-hidden='true' is not present on the document body."
        }
      },
      {
        "id": "aria-required-attr",
        "selector": "[role]",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "aria-required-attr"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.aria",
          "wcag2a",
          "wcag412"
        ],
        "preload": false,
        "metadata": {
          "help": "Required ARIA attributes must be provided",
          "description": "Ensures elements with ARIA roles have all required ARIA attributes",
          "mapping": {
            "ruleId": "ARIA_ROLE_REQUIRED_ATTRIBUTES",
            "SC": "4.1.1",
            "weight": 0,
            "description": "Checks all elements that contain WAI-ARIA roles to ensure that all required aria- attributes are present"
          }
        }
      },
      {
        "id": "aria-required-children",
        "selector": "[role]",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          {
            "options": {
              "reviewEmpty": [
                "listbox"
              ]
            },
            "id": "aria-required-children"
          }
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.aria",
          "wcag2a",
          "wcag131"
        ],
        "preload": false,
        "metadata": {
          "help": "Certain ARIA roles must contain particular children",
          "description": "Ensures elements with an ARIA role that require child roles contain them",
          "mapping": {
            "ruleId": "ARIA_ROLE_REQUIRED_CHILDREN",
            "SC": "4.1.1",
            "weight": 0,
            "description": "Checks all elements that contain a WAI-ARIA role to ensure that all required children roles are present"
          }
        }
      },
      {
        "id": "aria-required-parent",
        "selector": "[role]",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "aria-required-parent"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.aria",
          "wcag2a",
          "wcag131"
        ],
        "preload": false,
        "metadata": {
          "help": "Certain ARIA roles must be contained by particular parents",
          "description": "Ensures elements with an ARIA role that require parent roles are contained by them",
          "mapping": {
            "ruleId": "ARIA_ROLE_REQUIRED_PARENTS",
            "SC": "4.1.1",
            "weight": 0,
            "description": "Checks all elements that contain a WAI-ARIA role to ensure that all required parent roles are present"
          }
        }
      },
      {
        "id": "aria-roles",
        "selector": "[role]",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "invalidrole",
          "abstractrole",
          "unsupportedrole"
        ],
        "tags": [
          "cat.aria",
          "wcag2a",
          "wcag412"
        ],
        "preload": false,
        "metadata": {
          "help": "ARIA roles used must conform to valid values",
          "description": "Ensures all elements with a role attribute use a valid value",
          "mapping": {
            "ruleId": "ARIA_ROLE_VALID",
            "SC": "4.1.1",
            "weight": 0,
            "description": "Checks all elements that contain the WAI-ARIA role attribute to ensure that the role value is valid"
          }
        }
      },
      {
        "id": "aria-valid-attr-value",
        "selector": "*",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [
          {
            "options": [],
            "id": "aria-valid-attr-value"
          },
          "aria-errormessage"
        ],
        "none": [],
        "tags": [
          "cat.aria",
          "wcag2a",
          "wcag412"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var aria = /^aria-/;\n        if (node.hasAttributes()) {\n          var attrs = node.attributes;\n          for (var i = 0, l = attrs.length; i < l; i++) {\n            if (aria.test(attrs[i].name)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }",
        "metadata": {
          "help": "ARIA attributes must conform to valid values",
          "description": "Ensures all ARIA attributes have valid values",
          "mapping": {
            "ruleId": "ARIA_ATTRIBUTE_VALUES",
            "SC": "4.1.1",
            "weight": 0,
            "description": "Checks all elements that contain WAI-ARIA atributes to ensure that the values of the attributes are valid"
          }
        }
      },
      {
        "id": "aria-valid-attr",
        "selector": "*",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          {
            "options": [],
            "id": "aria-valid-attr"
          }
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.aria",
          "wcag2a",
          "wcag412"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var aria = /^aria-/;\n        if (node.hasAttributes()) {\n          var attrs = node.attributes;\n          for (var i = 0, l = attrs.length; i < l; i++) {\n            if (aria.test(attrs[i].name)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }",
        "metadata": {
          "help": "ARIA attributes must conform to valid names",
          "description": "Ensures attributes that begin with aria- are valid ARIA attributes",
          "mapping": {
            "ruleId": "ARIA_ATTRIBUTE_VALID",
            "SC": "4.1.1",
            "weight": 0,
            "description": "Checks all elements that contain WAI-ARIA attributes to ensure that the attributes are valid attributes"
          }
        }
      },
      {
        "id": "audio-caption",
        "selector": "audio",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "caption"
        ],
        "tags": [
          "cat.time-and-media",
          "wcag2a",
          "wcag121",
          "section508",
          "section508.22.a"
        ],
        "preload": false,
        "metadata": {
          "help": "<audio> elements must have a captions track",
          "description": "Ensures <audio> elements have captions",
          "mapping": {
            "ruleId": "010402-D",
            "SC": "1.2.2",
            "weight": 0,
            "description": "Checks the use of all <audio> element to ensure that the element contains a <caption> element"
          }
        }
      },
      {
        "id": "autocomplete-valid",
        "selector": "*",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [],
        "all": [
          "autocomplete-valid",
          "autocomplete-appropriate"
        ],
        "none": [],
        "tags": [
          "cat.forms",
          "wcag21aa",
          "wcag135"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var _axe$commons = axe.commons, text = _axe$commons.text, aria = _axe$commons.aria, dom = _axe$commons.dom;\n        var autocomplete = node.getAttribute('autocomplete');\n        if (!autocomplete || text.sanitize(autocomplete) === '') {\n          return false;\n        }\n        var nodeName = node.nodeName.toUpperCase();\n        if ([ 'TEXTAREA', 'INPUT', 'SELECT' ].includes(nodeName) === false) {\n          return false;\n        }\n        var excludedInputTypes = [ 'submit', 'reset', 'button', 'hidden' ];\n        if (nodeName === 'INPUT' && excludedInputTypes.includes(node.type)) {\n          return false;\n        }\n        var ariaDisabled = node.getAttribute('aria-disabled') || 'false';\n        if (node.disabled || ariaDisabled.toLowerCase() === 'true') {\n          return false;\n        }\n        var role = node.getAttribute('role');\n        var tabIndex = node.getAttribute('tabindex');\n        if (tabIndex === '-1' && role) {\n          var roleDef = aria.lookupTable.role[role];\n          if (roleDef === undefined || roleDef.type !== 'widget') {\n            return false;\n          }\n        }\n        if (tabIndex === '-1' && !dom.isVisible(node, false) && !dom.isVisible(node, true)) {\n          return false;\n        }\n        return true;\n      }",
        "metadata": {
          "help": "autocomplete attribute must be used correctly",
          "description": "Ensure the autocomplete attribute is correct and suitable for the form field"
        }
      },
      {
        "id": "blink",
        "selector": "blink",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "is-on-screen"
        ],
        "tags": [
          "cat.time-and-media",
          "wcag2a",
          "wcag222",
          "section508",
          "section508.22.j"
        ],
        "preload": false,
        "metadata": {
          "help": "<blink> elements are deprecated and must not be used",
          "description": "Ensures <blink> elements are not used",
          "mapping": {
            "ruleId": "070201-A",
            "SC": "2.2.2",
            "weight": 0,
            "description": "Checks to make sure that the <blink> tag is never used"
          }
        }
      },
      {
        "id": "button-name",
        "selector": "button, [role=\"button\"], input[type=\"button\"], input[type=\"submit\"], input[type=\"reset\"]",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "non-empty-if-present",
          "non-empty-value",
          "button-has-visible-text",
          "aria-label",
          "aria-labelledby",
          "role-presentation",
          "role-none",
          "non-empty-title"
        ],
        "all": [],
        "none": [
          "focusable-no-name"
        ],
        "tags": [
          "cat.name-role-value",
          "wcag2a",
          "wcag412",
          "section508",
          "section508.22.a"
        ],
        "preload": false,
        "metadata": {
          "help": "Buttons must have discernible text",
          "description": "Ensures buttons have discernible text",
          "mapping": {
            "ruleId": "SC412BTN",
            "SC": "1.1.1",
            "weight": 3,
            "description": "Checks all <button> elements to ensure that they have a discernable accessible name"
          }
        }
      },
      {
        "id": "bypass",
        "selector": "html",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": true,
        "any": [
          "internal-link-present",
          "header-present",
          "landmark"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.keyboard",
          "wcag2a",
          "wcag241",
          "section508",
          "section508.22.o"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return !!node.querySelector('a[href]');\n      }",
        "metadata": {
          "help": "Page must have means to bypass repeated blocks",
          "description": "Ensures each page has at least one mechanism for a user to bypass navigation and jump straight to the content",
          "mapping": {
            "ruleId": "N130601-A",
            "SC": "2.4.1",
            "weight": 3,
            "description": "There is no mechanism to bypass navigation links."
          }
        }
      },
      {
        "id": "checkboxgroup",
        "selector": "input[type=checkbox][name]",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [
          "group-labelledby",
          "fieldset"
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "Checkbox inputs with the same name attribute value must be part of a group",
          "description": "Ensures related <input type=\"checkbox\"> elements have a group and that the group designation is consistent",
          "mapping": {
            "ruleId": "SC131GROUP",
            "SC": "1.3.1",
            "weight": 3,
            "description": "Ensures that all checkbox groups have a group and that that group designation is consistent"
          }
        }
      },
      {
        "id": "color-contrast",
        "selector": "*",
        "excludeHidden": false,
        "enabled": false,
        "pageLevel": false,
        "any": [
          "color-contrast"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.color",
          "wcag2aa",
          "wcag143"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var nodeName = node.nodeName.toUpperCase(), nodeType = node.type;\n        if (node.getAttribute('aria-disabled') === 'true' || axe.commons.dom.findUpVirtual(virtualNode, '[aria-disabled=\"true\"]')) {\n          return false;\n        }\n        if (nodeName === 'INPUT') {\n          return [ 'hidden', 'range', 'color', 'checkbox', 'radio', 'image' ].indexOf(nodeType) === -1 && !node.disabled;\n        }\n        if (nodeName === 'SELECT') {\n          return !!node.options.length && !node.disabled;\n        }\n        if (nodeName === 'TEXTAREA') {\n          return !node.disabled;\n        }\n        if (nodeName === 'OPTION') {\n          return false;\n        }\n        if (nodeName === 'BUTTON' && node.disabled || axe.commons.dom.findUpVirtual(virtualNode, 'button[disabled]')) {\n          return false;\n        }\n        if (nodeName === 'FIELDSET' && node.disabled || axe.commons.dom.findUpVirtual(virtualNode, 'fieldset[disabled]')) {\n          return false;\n        }\n        var nodeParentLabel = axe.commons.dom.findUpVirtual(virtualNode, 'label');\n        if (nodeName === 'LABEL' || nodeParentLabel) {\n          var relevantNode = node;\n          var relevantVirtualNode = virtualNode;\n          if (nodeParentLabel) {\n            relevantNode = nodeParentLabel;\n            relevantVirtualNode = axe.utils.getNodeFromTree(axe._tree[0], nodeParentLabel);\n          }\n          var doc = axe.commons.dom.getRootNode(relevantNode);\n          var candidate = relevantNode.htmlFor && doc.getElementById(relevantNode.htmlFor);\n          if (candidate && candidate.disabled) {\n            return false;\n          }\n          var candidate = axe.utils.querySelectorAll(relevantVirtualNode, 'input:not([type=\"hidden\"]):not([type=\"image\"])' + ':not([type=\"button\"]):not([type=\"submit\"]):not([type=\"reset\"]), select, textarea');\n          if (candidate.length && candidate[0].actualNode.disabled) {\n            return false;\n          }\n        }\n        if (node.getAttribute('id')) {\n          var id = axe.commons.utils.escapeSelector(node.getAttribute('id'));\n          var _doc = axe.commons.dom.getRootNode(node);\n          var candidate = _doc.querySelector('[aria-labelledby~=' + id + ']');\n          if (candidate && candidate.disabled) {\n            return false;\n          }\n        }\n        if (axe.commons.text.visibleVirtual(virtualNode, false, true) === '') {\n          return false;\n        }\n        var range = document.createRange(), childNodes = virtualNode.children, length = childNodes.length, child, index;\n        for (index = 0; index < length; index++) {\n          child = childNodes[index];\n          if (child.actualNode.nodeType === 3 && axe.commons.text.sanitize(child.actualNode.nodeValue) !== '') {\n            range.selectNodeContents(child.actualNode);\n          }\n        }\n        var rects = range.getClientRects();\n        length = rects.length;\n        for (index = 0; index < length; index++) {\n          if (axe.commons.dom.visuallyOverlaps(rects[index], node)) {\n            return true;\n          }\n        }\n        return false;\n      }",
        "metadata": {
          "help": "Elements must have sufficient color contrast",
          "description": "Ensures the contrast between foreground and background colors meets WCAG 2 AA contrast ratio thresholds",
          "mapping": {
            "ruleId": "020201-A",
            "SC": "1.4.3",
            "weight": 2,
            "description": "Checks all elements to ensure that the contrast between the foreground and the background meets the WCAG 2 AA contrast ratio thresholds."
          }
        }
      },
      {
        "id": "css-orientation-lock",
        "selector": "html",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [],
        "all": [
          "css-orientation-lock"
        ],
        "none": [],
        "tags": [],
        "preload": true,
        "metadata": {
          "help": "CSS Media queries are not used to lock display orientation",
          "description": "Ensures content is not locked to any specific display orientation, and the content is operable in all display orientations"
        }
      },
      {
        "id": "definition-list",
        "selector": "dl",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "structured-dlitems",
          "only-dlitems"
        ],
        "tags": [
          "cat.structure",
          "wcag2a",
          "wcag131"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return !node.getAttribute('role');\n      }",
        "metadata": {
          "help": "<dl> elements must only directly contain properly-ordered <dt> and <dd> groups, <script> or <template> elements",
          "description": "Ensures <dl> elements are structured correctly",
          "mapping": {
            "ruleId": "SC411VAL",
            "SC": "4.1.1",
            "weight": 0,
            "description": "Ensures that all <dl> elements are structured correctly"
          }
        }
      },
      {
        "id": "dlitem",
        "selector": "dd, dt",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "dlitem"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.structure",
          "wcag2a",
          "wcag131"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return !node.getAttribute('role');\n      }",
        "metadata": {
          "help": "<dt> and <dd> elements must be contained by a <dl>",
          "description": "Ensures <dt> and <dd> elements are contained by a <dl>",
          "mapping": {
            "ruleId": "SC411VAL",
            "SC": "4.1.1",
            "weight": 0,
            "description": "Ensures that all <dd> and <dt> elements have a <dl> as a parent"
          }
        }
      },
      {
        "id": "document-title",
        "selector": "html",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "doc-has-title"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.text-alternatives",
          "wcag2a",
          "wcag242"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return node.ownerDocument.defaultView.self === node.ownerDocument.defaultView.top;\n      }",
        "metadata": {
          "help": "Documents must have <title> element to aid in navigation",
          "description": "Ensures each HTML document contains a non-empty <title> element",
          "mapping": {
            "ruleId": "130201-C",
            "SC": "2.4.2",
            "weight": 0,
            "description": "Supply a valid title element for this document that is non-empty and useful."
          }
        }
      },
      {
        "id": "duplicate-id-active",
        "selector": "[id]",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "duplicate-id-active"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.parsing",
          "wcag2a",
          "wcag411"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var _axe$commons2 = axe.commons, dom = _axe$commons2.dom, aria = _axe$commons2.aria;\n        var id = node.getAttribute('id').trim();\n        var idSelector = '*[id=\"' + axe.utils.escapeSelector(id) + '\"]';\n        var idMatchingElms = Array.from(dom.getRootNode(node).querySelectorAll(idSelector));\n        return idMatchingElms.some(dom.isFocusable) && !aria.isAccessibleRef(node);\n      }",
        "metadata": {
          "help": "IDs of active elements must be unique",
          "description": "Ensures every id attribute value of active elements is unique"
        }
      },
      {
        "id": "duplicate-id-aria",
        "selector": "[id]",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "duplicate-id-aria"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.parsing",
          "wcag2a",
          "wcag411"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return axe.commons.aria.isAccessibleRef(node);\n      }",
        "metadata": {
          "help": "IDs used in ARIA and labels must be unique",
          "description": "Ensures every id attribute value used in ARIA and in labels is unique"
        }
      },
      {
        "id": "duplicate-id",
        "selector": "[id]",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "duplicate-id"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.parsing",
          "wcag2a",
          "wcag411"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var _axe$commons3 = axe.commons, dom = _axe$commons3.dom, aria = _axe$commons3.aria;\n        var id = node.getAttribute('id').trim();\n        var idSelector = '*[id=\"' + axe.utils.escapeSelector(id) + '\"]';\n        var idMatchingElms = Array.from(dom.getRootNode(node).querySelectorAll(idSelector));\n        return idMatchingElms.every(function(elm) {\n          return !dom.isFocusable(elm);\n        }) && !aria.isAccessibleRef(node);\n      }",
        "metadata": {
          "help": "id attribute value must be unique",
          "description": "Ensures every id attribute value is unique",
          "mapping": {
            "ruleId": "SC411NID",
            "SC": "4.1.1",
            "weight": 0,
            "description": "Ensures that each element on the page with an ID attribute has a unique ID attribute value"
          }
        }
      },
      {
        "id": "empty-heading",
        "selector": "h1, h2, h3, h4, h5, h6, [role=\"heading\"]",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [
          "has-visible-text"
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var explicitRoles = void 0;\n        if (node.hasAttribute('role')) {\n          explicitRoles = node.getAttribute('role').split(/\\s+/i).filter(axe.commons.aria.isValidRole);\n        }\n        if (explicitRoles && explicitRoles.length > 0) {\n          return explicitRoles.includes('heading');\n        } else {\n          return axe.commons.aria.implicitRole(node) === 'heading';\n        }\n      }",
        "metadata": {
          "help": "Headings must not be empty",
          "description": "Ensures headings have discernible text"
        }
      },
      {
        "id": "focus-order-semantics",
        "selector": "div, h1, h2, h3, h4, h5, h6, [role=heading], p, span",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [
          {
            "options": [],
            "id": "has-widget-role"
          },
          {
            "options": [],
            "id": "valid-scrollable-semantics"
          }
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return axe.commons.dom.insertedIntoFocusOrder(node);\n      }",
        "metadata": {
          "help": "Elements in the focus order need a role appropriate for interactive content",
          "description": "Ensures elements in the focus order have an appropriate role"
        }
      },
      {
        "id": "frame-tested",
        "selector": "frame, iframe",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [],
        "all": [
          {
            "options": {
              "isViolation": false
            },
            "id": "frame-tested"
          }
        ],
        "none": [],
        "tags": [
          "cat.structure",
          "review-item"
        ],
        "preload": false,
        "metadata": {
          "help": "Frames must be tested with axe-core",
          "description": "Ensures <iframe> and <frame> elements contain the axe-core script"
        }
      },
      {
        "id": "frame-title-unique",
        "selector": "frame[title], iframe[title]",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "unique-frame-title"
        ],
        "tags": [],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var title = node.getAttribute('title');\n        return !!(title ? axe.commons.text.sanitize(title).trim() : '');\n      }",
        "metadata": {
          "help": "Frames must have a unique title attribute",
          "description": "Ensures <iframe> and <frame> elements contain a unique title attribute"
        }
      },
      {
        "id": "frame-title",
        "selector": "frame, iframe",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "aria-label",
          "aria-labelledby",
          "non-empty-title",
          "role-presentation",
          "role-none"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.text-alternatives",
          "wcag2a",
          "wcag241",
          "wcag412",
          "section508",
          "section508.22.i"
        ],
        "preload": false,
        "metadata": {
          "help": "Frames must have title attribute",
          "description": "Ensures <iframe> and <frame> elements contain a non-empty title attribute",
          "mapping": {
            "ruleId": "120101-A",
            "SC": "4.1.2",
            "weight": 2,
            "description": "Ensure that all iframe and frame elements contain a unique and non-empty title attribute"
          }
        }
      },
      {
        "id": "heading-order",
        "selector": "h1, h2, h3, h4, h5, h6, [role=heading]",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [
          "heading-order"
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var explicitRoles = void 0;\n        if (node.hasAttribute('role')) {\n          explicitRoles = node.getAttribute('role').split(/\\s+/i).filter(axe.commons.aria.isValidRole);\n        }\n        if (explicitRoles && explicitRoles.length > 0) {\n          return explicitRoles.includes('heading');\n        } else {\n          return axe.commons.aria.implicitRole(node) === 'heading';\n        }\n      }",
        "metadata": {
          "help": "Heading levels should only increase by one",
          "description": "Ensures the order of headings is semantically correct",
          "mapping": {
            "ruleId": "N030501-A",
            "SC": "1.3.1",
            "weight": 3,
            "description": "Ensure that the order in which the headings appear in the DOM is semantically correct"
          }
        }
      },
      {
        "id": "hidden-content",
        "selector": "*",
        "excludeHidden": false,
        "enabled": false,
        "pageLevel": false,
        "any": [
          "hidden-content"
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "Hidden content on the page cannot be analyzed",
          "description": "Informs users about hidden content."
        }
      },
      {
        "id": "html-has-lang",
        "selector": "html",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "has-lang"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.language",
          "wcag2a",
          "wcag311"
        ],
        "preload": false,
        "metadata": {
          "help": "<html> element must have a lang attribute",
          "description": "Ensures every HTML document has a lang attribute"
        }
      },
      {
        "id": "html-lang-valid",
        "selector": "html[lang]",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "valid-lang"
        ],
        "tags": [
          "cat.language",
          "wcag2a",
          "wcag311"
        ],
        "preload": false,
        "metadata": {
          "help": "<html> element must have a valid value for the lang attribute",
          "description": "Ensures the lang attribute of the <html> element has a valid value"
        }
      },
      {
        "id": "html-xml-lang-mismatch",
        "selector": "html[lang][xml\\:lang]",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [
          "xml-lang-mismatch"
        ],
        "none": [],
        "tags": [
          "cat.language",
          "wcag2a",
          "wcag311"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var getBaseLang = axe.commons.utils.getBaseLang;\n        var primaryLangValue = getBaseLang(node.getAttribute('lang'));\n        var primaryXmlLangValue = getBaseLang(node.getAttribute('xml:lang'));\n        return axe.utils.validLangs().includes(primaryLangValue) && axe.utils.validLangs().includes(primaryXmlLangValue);\n      }",
        "metadata": {
          "help": "HTML elements with lang and xml:lang must have the same base language",
          "description": "Ensure that HTML elements with both valid lang and xml:lang attributes agree on the base language of the page"
        }
      },
      {
        "id": "image-alt",
        "selector": "img, [role='img']:not(svg)",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "has-alt",
          "aria-label",
          "aria-labelledby",
          "non-empty-title",
          "role-presentation",
          "role-none"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.text-alternatives",
          "wcag2a",
          "wcag111",
          "section508",
          "section508.22.a"
        ],
        "preload": false,
        "metadata": {
          "help": "Images must have alternate text",
          "description": "Ensures <img> elements have alternate text or a role of none or presentation",
          "mapping": {
            "ruleId": "IMG_NO_ALT",
            "SC": "1.1.1",
            "weight": 0,
            "description": "Ensures that every <img> element has an alternative text or is marked as presentational"
          }
        }
      },
      {
        "id": "image-redundant-alt",
        "selector": "button, [role=\"button\"], a[href], p, li, td, th",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "duplicate-img-label"
        ],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "Text of buttons and links should not be repeated in the image alternative",
          "description": "Ensure button and link text is not repeated as image alternative"
        }
      },
      {
        "id": "input-image-alt",
        "selector": "input[type=\"image\"]",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "non-empty-alt",
          "aria-label",
          "aria-labelledby",
          "non-empty-title"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.text-alternatives",
          "wcag2a",
          "wcag111",
          "section508",
          "section508.22.a"
        ],
        "preload": false,
        "metadata": {
          "help": "Image buttons must have alternate text",
          "description": "Ensures <input type=\"image\"> elements have alternate text",
          "mapping": {
            "ruleId": "010103-A",
            "SC": "1.1.1",
            "weight": 0,
            "description": "Ensures that every <input> that represents an image button has an accessible name"
          }
        }
      },
      {
        "id": "label-title-only",
        "selector": "input, select, textarea",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "title-only"
        ],
        "tags": [],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        if (node.nodeName.toLowerCase() !== 'input' || node.hasAttribute('type') === false) {\n          return true;\n        }\n        var type = node.getAttribute('type').toLowerCase();\n        return [ 'hidden', 'image', 'button', 'submit', 'reset' ].includes(type) === false;\n      }",
        "metadata": {
          "help": "Form elements should have a visible label",
          "description": "Ensures that every form element is not solely labeled using the title or aria-describedby attributes",
          "mapping": {
            "ruleId": "120401-E",
            "SC": "1.3.1",
            "weight": 2,
            "description": "Ensures that every <input> that requires a label is not only labeled using the title attribute"
          }
        }
      },
      {
        "id": "label",
        "selector": "input, select, textarea",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "aria-label",
          "aria-labelledby",
          "implicit-label",
          "explicit-label",
          "non-empty-title"
        ],
        "all": [],
        "none": [
          "help-same-as-label",
          "multiple-label",
          "hidden-explicit-label"
        ],
        "tags": [
          "cat.forms",
          "wcag2a",
          "wcag332",
          "wcag131",
          "section508",
          "section508.22.n"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        if (node.nodeName.toLowerCase() !== 'input' || node.hasAttribute('type') === false) {\n          return true;\n        }\n        var type = node.getAttribute('type').toLowerCase();\n        return [ 'hidden', 'image', 'button', 'submit', 'reset' ].includes(type) === false;\n      }",
        "metadata": {
          "help": "Form elements must have labels",
          "description": "Ensures every form element has a label",
          "mapping": {
            "ruleId": "120401-E",
            "SC": "1.3.1",
            "weight": 0,
            "description": "Ensures that every input element that requires a label, has an appropriate label"
          }
        }
      },
      {
        "id": "landmark-banner-is-top-level",
        "selector": "header:not([role]), [role=banner]",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [
          "landmark-is-top-level"
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var nativeScopeFilter = 'article, aside, main, nav, section';\n        return node.hasAttribute('role') || !axe.commons.dom.findUpVirtual(virtualNode, nativeScopeFilter);\n      }",
        "metadata": {
          "help": "Banner landmark must not be contained in another landmark",
          "description": "Ensures the banner landmark is at top level"
        }
      },
      {
        "id": "landmark-contentinfo-is-top-level",
        "selector": "footer:not([role]), [role=contentinfo]",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [
          "landmark-is-top-level"
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var nativeScopeFilter = 'article, aside, main, nav, section';\n        return node.hasAttribute('role') || !axe.commons.dom.findUpVirtual(virtualNode, nativeScopeFilter);\n      }",
        "metadata": {
          "help": "Contentinfo landmark must not be contained in another landmark",
          "description": "Ensures the contentinfo landmark is at top level"
        }
      },
      {
        "id": "landmark-main-is-top-level",
        "selector": "main:not([role]), [role=main]",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [
          "landmark-is-top-level"
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "Main landmark must not be contained in another landmark",
          "description": "Ensures the main landmark is at top level"
        }
      },
      {
        "id": "landmark-no-duplicate-banner",
        "selector": "html",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [
          {
            "options": {
              "selector": "header:not([role]), [role=banner]",
              "nativeScopeFilter": "article, aside, main, nav, section"
            },
            "id": "page-no-duplicate-banner"
          }
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "Page must not have more than one banner landmark",
          "description": "Ensures the page has at most one banner landmark"
        }
      },
      {
        "id": "landmark-no-duplicate-contentinfo",
        "selector": "html",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [
          {
            "options": {
              "selector": "footer:not([role]), [role=contentinfo]",
              "nativeScopeFilter": "article, aside, main, nav, section"
            },
            "id": "page-no-duplicate-contentinfo"
          }
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "Page must not have more than one contentinfo landmark",
          "description": "Ensures the page has at most one contentinfo landmark"
        }
      },
      {
        "id": "landmark-one-main",
        "selector": "html",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [],
        "all": [
          {
            "options": {
              "selector": "main:not([role]), [role='main']"
            },
            "id": "page-has-main"
          },
          {
            "options": {
              "selector": "main:not([role]), [role='main']"
            },
            "id": "page-no-duplicate-main"
          }
        ],
        "none": [],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "Page must have one main landmark",
          "description": "Ensures the page has only one main landmark and each iframe in the page has at most one main landmark"
        }
      },
      {
        "id": "layout-table",
        "selector": "table",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "has-th",
          "has-caption",
          "has-summary"
        ],
        "tags": [
          "cat.semantics",
          "wcag2a",
          "wcag131"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var role = (node.getAttribute('role') || '').toLowerCase();\n        return !((role === 'presentation' || role === 'none') && !axe.commons.dom.isFocusable(node)) && !axe.commons.table.isDataTable(node);\n      }",
        "metadata": {
          "help": "Layout tables must not use data table elements",
          "description": "Ensures presentational <table> elements do not use <th>, <caption> elements or the summary attribute",
          "mapping": {
            "ruleId": "050401-A",
            "SC": "1.3.1",
            "weight": 1,
            "description": "Ensures that <table> elements that are being used for layout do not contain markup only relevant for data tables"
          }
        }
      },
      {
        "id": "link-in-text-block",
        "selector": "a[href], [role=link]",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [
          "link-in-text-block"
        ],
        "none": [],
        "tags": [
          "cat.color",
          "experimental",
          "wcag2a",
          "wcag141"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var text = axe.commons.text.sanitize(node.textContent);\n        var role = node.getAttribute('role');\n        if (role && role !== 'link') {\n          return false;\n        }\n        if (!text) {\n          return false;\n        }\n        if (!axe.commons.dom.isVisible(node, false)) {\n          return false;\n        }\n        return axe.commons.dom.isInTextBlock(node);\n      }",
        "metadata": {
          "help": "Links must be distinguished from surrounding text in a way that does not rely on color",
          "description": "Links can be distinguished without relying on color"
        }
      },
      {
        "id": "link-name",
        "selector": "a[href], [role=link][href]",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "has-visible-text",
          "aria-label",
          "aria-labelledby",
          "role-presentation",
          "role-none"
        ],
        "all": [],
        "none": [
          "focusable-no-name"
        ],
        "tags": [
          "cat.name-role-value",
          "wcag2a",
          "wcag412",
          "wcag244",
          "section508",
          "section508.22.a"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return node.getAttribute('role') !== 'button';\n      }",
        "metadata": {
          "help": "Links must have discernible text",
          "description": "Ensures links have discernible text",
          "mapping": {
            "ruleId": "SC412LNKN",
            "SC": "4.1.2",
            "weight": 1,
            "description": "Ensures that every link has an accessible name"
          }
        }
      },
      {
        "id": "list",
        "selector": "ul, ol",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "only-listitems"
        ],
        "tags": [
          "cat.structure",
          "wcag2a",
          "wcag131"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return !node.getAttribute('role');\n      }",
        "metadata": {
          "help": "<ul> and <ol> must only directly contain <li>, <script> or <template> elements",
          "description": "Ensures that lists are structured correctly",
          "mapping": {
            "ruleId": "030601-C",
            "SC": "1.3.1",
            "weight": 1,
            "description": "Ensures that lists are structured correctly"
          }
        }
      },
      {
        "id": "listitem",
        "selector": "li",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "listitem"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.structure",
          "wcag2a",
          "wcag131"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return !node.getAttribute('role');\n      }",
        "metadata": {
          "help": "<li> elements must be contained in a <ul> or <ol>",
          "description": "Ensures <li> elements are used semantically",
          "mapping": {
            "ruleId": "030601-A",
            "SC": "1.3.1",
            "weight": 1,
            "description": "Ensures that every list item is used semantically"
          }
        }
      },
      {
        "id": "marquee",
        "selector": "marquee",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "is-on-screen"
        ],
        "tags": [
          "cat.parsing",
          "wcag2a",
          "wcag222"
        ],
        "preload": false,
        "metadata": {
          "help": "<marquee> elements are deprecated and must not be used",
          "description": "Ensures <marquee> elements are not used",
          "mapping": {
            "ruleId": "070301-A",
            "SC": "2.2.2",
            "weight": 0,
            "description": "Ensures that the deprecated <marquee> tag is not used"
          }
        }
      },
      {
        "id": "meta-refresh",
        "selector": "meta[http-equiv=\"refresh\"]",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "meta-refresh"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.time",
          "wcag2a",
          "wcag2aaa",
          "wcag221",
          "wcag224",
          "wcag325"
        ],
        "preload": false,
        "metadata": {
          "help": "Timed refresh must not exist",
          "description": "Ensures <meta http-equiv=\"refresh\"> is not used",
          "mapping": {
            "ruleId": "070401-A",
            "SC": "2.2.4",
            "weight": 1,
            "description": "Ensures that <meta> refresh is not used"
          }
        }
      },
      {
        "id": "meta-viewport-large",
        "selector": "meta[name=\"viewport\"]",
        "excludeHidden": false,
        "enabled": false,
        "pageLevel": false,
        "any": [
          {
            "options": {
              "scaleMinimum": 5,
              "lowerBound": 2
            },
            "id": "meta-viewport-large"
          }
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "Users should be able to zoom and scale the text up to 500%",
          "description": "Ensures <meta name=\"viewport\"> can scale a significant amount",
          "mapping": {}
        }
      },
      {
        "id": "meta-viewport",
        "selector": "meta[name=\"viewport\"]",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [
          {
            "options": {
              "scaleMinimum": 2
            },
            "id": "meta-viewport"
          }
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.sensory-and-visual-cues",
          "wcag2aa",
          "wcag144"
        ],
        "preload": false,
        "metadata": {
          "help": "Zooming and scaling must not be disabled",
          "description": "Ensures <meta name=\"viewport\"> does not disable text scaling and zooming",
          "mapping": {}
        }
      },
      {
        "id": "object-alt",
        "selector": "object",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [
          "has-visible-text",
          "aria-label",
          "aria-labelledby",
          "non-empty-title"
        ],
        "all": [],
        "none": [],
        "tags": [
          "cat.text-alternatives",
          "wcag2a",
          "wcag111",
          "section508",
          "section508.22.a"
        ],
        "preload": false,
        "metadata": {
          "help": "<object> elements must have alternate text",
          "description": "Ensures <object> elements have alternate text",
          "mapping": {
            "ruleId": "010105-A",
            "SC": "1.1.1",
            "weight": 0,
            "description": "Ensures that every <object> element has a text alternative"
          }
        }
      },
      {
        "id": "p-as-heading",
        "selector": "p",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [
          {
            "options": {
              "margins": [
                {
                  "weight": 150,
                  "italic": true
                },
                {
                  "weight": 150,
                  "size": 1.15
                },
                {
                  "italic": true,
                  "size": 1.15
                },
                {
                  "size": 1.4
                }
              ]
            },
            "id": "p-as-heading"
          }
        ],
        "none": [],
        "tags": [
          "cat.semantics",
          "wcag2a",
          "wcag131",
          "experimental"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        var children = Array.from(node.parentNode.childNodes);\n        var nodeText = node.textContent.trim();\n        var isSentence = /[.!?:;](?![.!?:;])/g;\n        if (nodeText.length === 0 || (nodeText.match(isSentence) || []).length >= 2) {\n          return false;\n        }\n        var siblingsAfter = children.slice(children.indexOf(node) + 1).filter(function(elm) {\n          return elm.nodeName.toUpperCase() === 'P' && elm.textContent.trim() !== '';\n        });\n        return siblingsAfter.length !== 0;\n      }",
        "metadata": {
          "help": "Bold, italic text and font-size are not used to style p elements as a heading",
          "description": "Ensure p elements are not used to style headings"
        }
      },
      {
        "id": "page-has-heading-one",
        "selector": "html",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [],
        "all": [
          {
            "options": {
              "selector": "h1:not([role]), [role=\"heading\"][aria-level=\"1\"]"
            },
            "id": "page-has-heading-one"
          }
        ],
        "none": [],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "Page must contain a level-one heading",
          "description": "Ensure that the page, or at least one of its frames contains a level-one heading"
        }
      },
      {
        "id": "radiogroup",
        "selector": "input[type=radio][name]",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [
          "group-labelledby",
          "fieldset"
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "Radio inputs with the same name attribute value must be part of a group",
          "description": "Ensures related <input type=\"radio\"> elements have a group and that the group designation is consistent",
          "mapping": {
            "ruleId": "SC131GROUP",
            "SC": "1.3.1",
            "weight": 3,
            "description": "Ensures that radio button groups are part of a group structure"
          }
        }
      },
      {
        "id": "region",
        "selector": "html",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": true,
        "any": [
          "region"
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "All page content must be contained by landmarks",
          "description": "Ensures all page content is contained by landmarks",
          "mapping": {
            "SC": "2.4.1",
            "weight": 2,
            "description": "Ensures that all content on a page is contained within a landmark region"
          }
        }
      },
      {
        "id": "scope-attr-valid",
        "selector": "td[scope], th[scope]",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [],
        "all": [
          "html5-scope",
          "scope-value"
        ],
        "none": [],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "scope attribute should be used correctly",
          "description": "Ensures the scope attribute is used correctly on tables",
          "mapping": {
            "ruleId": "050102-D",
            "SC": "1.3.1",
            "weight": 1,
            "description": "Ensures that the scope attribute is used correctly on tables"
          }
        }
      },
      {
        "id": "server-side-image-map",
        "selector": "img[ismap]",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "exists"
        ],
        "tags": [
          "cat.text-alternatives",
          "wcag2a",
          "wcag211",
          "section508",
          "section508.22.f"
        ],
        "preload": false,
        "metadata": {
          "help": "Server-side image maps must not be used",
          "description": "Ensures that server-side image maps are not used",
          "mapping": {
            "ruleId": "090101-A",
            "SC": "2.1.1",
            "weight": 0,
            "description": "Ensures that server-side image maps are never used"
          }
        }
      },
      {
        "id": "skip-link",
        "selector": "a[href]",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [
          "skip-link"
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return /^#[^/!]/.test(node.getAttribute('href'));\n      }",
        "metadata": {
          "help": "The skip-link target should exist and be focusable",
          "description": "Ensure all skip links have a focusable target",
          "mapping": {
            "ruleId": "SC241SKP",
            "SC": "2.4.1",
            "weight": 2,
            "description": "There is no mechanism to skip to the main content of the page"
          }
        }
      },
      {
        "id": "tabindex",
        "selector": "[tabindex]",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [
          "tabindex"
        ],
        "all": [],
        "none": [],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "Elements should not have tabindex greater than zero",
          "description": "Ensures tabindex attribute values are not greater than 0",
          "mapping": {}
        }
      },
      {
        "id": "table-duplicate-name",
        "selector": "table",
        "excludeHidden": true,
        "enabled": false,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "same-caption-summary"
        ],
        "tags": [],
        "preload": false,
        "metadata": {
          "help": "The <caption> element should not contain the same text as the summary attribute",
          "description": "Ensure that tables do not have the same summary and caption",
          "mapping": {}
        }
      },
      {
        "id": "table-fake-caption",
        "selector": "table",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [
          "caption-faked"
        ],
        "none": [],
        "tags": [
          "cat.tables",
          "experimental",
          "wcag2a",
          "wcag131",
          "section508",
          "section508.22.g"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return axe.commons.table.isDataTable(node);\n      }",
        "metadata": {
          "help": "Data or header cells should not be used to give caption to a data table.",
          "description": "Ensure that tables with a caption use the <caption> element.",
          "mapping": {}
        }
      },
      {
        "id": "td-has-header",
        "selector": "table",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [
          "td-has-header"
        ],
        "none": [],
        "tags": [
          "cat.tables",
          "experimental",
          "wcag2a",
          "wcag131",
          "section508",
          "section508.22.g"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        if (axe.commons.table.isDataTable(node)) {\n          var tableArray = axe.commons.table.toArray(node);\n          return tableArray.length >= 3 && tableArray[0].length >= 3 && tableArray[1].length >= 3 && tableArray[2].length >= 3;\n        }\n        return false;\n      }",
        "metadata": {
          "help": "All non-empty td element in table larger than 3 by 3 must have an associated table header",
          "description": "Ensure that each non-empty data cell in a large table has one or more table headers",
          "mapping": {}
        }
      },
      {
        "id": "td-headers-attr",
        "selector": "table",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [
          "td-headers-attr"
        ],
        "none": [],
        "tags": [
          "cat.tables",
          "wcag2a",
          "wcag131",
          "section508",
          "section508.22.g"
        ],
        "preload": false,
        "metadata": {
          "help": "All cells in a table element that use the headers attribute must only refer to other cells of that same table",
          "description": "Ensure that each cell in a table using the headers refers to another cell in that table"
        }
      },
      {
        "id": "th-has-data-cells",
        "selector": "table",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [
          "th-has-data-cells"
        ],
        "none": [],
        "tags": [
          "cat.tables",
          "wcag2a",
          "wcag131",
          "section508",
          "section508.22.g"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return axe.commons.table.isDataTable(node);\n      }",
        "metadata": {
          "help": "All th elements and elements with role=columnheader/rowheader must have data cells they describe",
          "description": "Ensure that each table header in a data table refers to data cells",
          "mapping": {}
        }
      },
      {
        "id": "valid-lang",
        "selector": "[lang], [xml\\:lang]",
        "excludeHidden": true,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "valid-lang"
        ],
        "tags": [
          "cat.language",
          "wcag2aa",
          "wcag312"
        ],
        "preload": false,
        "matches": "function matches(node, virtualNode) {\n        return node.nodeName.toLowerCase() !== 'html';\n      }",
        "metadata": {
          "help": "lang attribute must have a valid value",
          "description": "Ensures lang attributes have valid values",
          "mapping": {
            "ruleId": "040101-B",
            "SC": "3.1.2",
            "weight": 1,
            "description": "Ensures that when the 'lang' attribute is used, it has a valid value"
          }
        }
      },
      {
        "id": "video-caption",
        "selector": "video",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "caption"
        ],
        "tags": [
          "cat.text-alternatives",
          "wcag2a",
          "wcag122",
          "section508",
          "section508.22.a"
        ],
        "preload": false,
        "metadata": {
          "help": "<video> elements must have captions",
          "description": "Ensures <video> elements have captions",
          "mapping": {
            "ruleId": "010402-D",
            "SC": "1.2.2",
            "weight": 1,
            "description": "Ensures that the HTML5 <video> tag is captioned"
          }
        }
      },
      {
        "id": "video-description",
        "selector": "video",
        "excludeHidden": false,
        "enabled": true,
        "pageLevel": false,
        "any": [],
        "all": [],
        "none": [
          "description"
        ],
        "tags": [
          "cat.text-alternatives",
          "wcag2aa",
          "wcag125",
          "section508",
          "section508.22.b"
        ],
        "preload": false,
        "metadata": {
          "help": "<video> elements must have an audio description track",
          "description": "Ensures <video> elements have audio descriptions",
          "mapping": {
            "ruleId": "010301-Q1",
            "SC": "1.2.5",
            "weight": 1,
            "description": "Ensures that every <video> tag has an audio description"
          }
        }
      },
      {
        "id": "anchor-page-link-button",
        "selector": "a, [role=\"link\"]",
        "metadata": {
          "description": "This custom rule ensures that all links go somewhere and buttons are used to do something. For example a page anchor (a href=\"#show-modal\") should be a button instead.",
          "help": "Page-anchors should be buttons"
        },
        "all": [
          "anchor-page-link-button"
        ],
        "any": [],
        "none": [],
        "enabled": true
      }
    ],
    "checks": [
      {
        "id": "accesskeys",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (axe.commons.dom.isVisible(node, false)) {\n          this.data(node.getAttribute('accesskey'));\n          this.relatedNodes([ node ]);\n        }\n        return true;\n      }",
        "after": "function after(results, options) {\n        var seen = {};\n        return results.filter(function(r) {\n          if (!r.data) {\n            return false;\n          }\n          var key = r.data.toUpperCase();\n          if (!seen[key]) {\n            seen[key] = r;\n            r.relatedNodes = [];\n            return true;\n          }\n          seen[key].relatedNodes.push(r.relatedNodes[0]);\n          return false;\n        }).map(function(r) {\n          r.result = !!r.relatedNodes.length;\n          return r;\n        });\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Accesskey attribute value is unique';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Document has multiple elements with the same accesskey';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "non-empty-alt",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var label = node.getAttribute('alt');\n        return !!(label ? axe.commons.text.sanitize(label).trim() : '');\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element has a non-empty alt attribute';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element has no alt attribute or the alt attribute is empty';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "non-empty-title",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var title = node.getAttribute('title');\n        return !!(title ? axe.commons.text.sanitize(title).trim() : '');\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element has a title attribute';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element has no title attribute or the title attribute is empty';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "aria-label",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var label = node.getAttribute('aria-label');\n        return !!(label ? axe.commons.text.sanitize(label).trim() : '');\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'aria-label attribute exists and is not empty';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'aria-label attribute does not exist or is empty';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "aria-labelledby",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var getIdRefs = axe.commons.dom.idrefs;\n        return getIdRefs(node, 'aria-labelledby').some(function(elm) {\n          return elm && axe.commons.text.accessibleText(elm, true);\n        });\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'aria-labelledby attribute exists and references elements that are visible to screen readers';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'aria-labelledby attribute does not exist, references elements that do not exist or references elements that are empty';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "aria-allowed-attr",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = options || {};\n        var invalid = [];\n        var attr, attrName, allowed, role = node.getAttribute('role'), attrs = node.attributes;\n        if (!role) {\n          role = axe.commons.aria.implicitRole(node);\n        }\n        allowed = axe.commons.aria.allowedAttr(role);\n        if (Array.isArray(options[role])) {\n          allowed = axe.utils.uniqueArray(options[role].concat(allowed));\n        }\n        if (role && allowed) {\n          for (var i = 0, l = attrs.length; i < l; i++) {\n            attr = attrs[i];\n            attrName = attr.name;\n            if (axe.commons.aria.validateAttr(attrName) && !allowed.includes(attrName)) {\n              invalid.push(attrName + '=\"' + attr.nodeValue + '\"');\n            }\n          }\n        }\n        if (invalid.length) {\n          this.data(invalid);\n          return false;\n        }\n        return true;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'ARIA attributes are used correctly for the defined role';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'ARIA attribute' + (it.data && it.data.length > 1 ? 's are' : ' is') + ' not allowed:';\n              var arr1 = it.data;\n              if (arr1) {\n                var value, i1 = -1, l1 = arr1.length - 1;\n                while (i1 < l1) {\n                  value = arr1[i1 += 1];\n                  out += ' ' + value;\n                }\n              }\n              return out;\n            }"
          }
        }
      },
      {
        "id": "aria-allowed-role",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _ref = options || {}, _ref$allowImplicit = _ref.allowImplicit, allowImplicit = _ref$allowImplicit === undefined ? true : _ref$allowImplicit, _ref$ignoredTags = _ref.ignoredTags, ignoredTags = _ref$ignoredTags === undefined ? [] : _ref$ignoredTags;\n        var tagName = node.nodeName.toUpperCase();\n        if (ignoredTags.map(function(t) {\n          return t.toUpperCase();\n        }).includes(tagName)) {\n          return true;\n        }\n        var unallowedRoles = axe.commons.aria.getElementUnallowedRoles(node, allowImplicit);\n        if (unallowedRoles.length) {\n          this.data(unallowedRoles);\n          return false;\n        }\n        return true;\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'ARIA role is allowed for given element';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'role' + (it.data && it.data.length > 1 ? 's' : '') + ' ' + it.data.join(', ') + ' ' + (it.data && it.data.length > 1 ? 'are' : ' is') + ' not allowed for given element';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "implicit-role-fallback",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var role = node.getAttribute('role');\n        if (role === null || !axe.commons.aria.isValidRole(role)) {\n          return true;\n        }\n        var roleType = axe.commons.aria.getRoleType(role);\n        return axe.commons.aria.implicitRole(node) === roleType;\n      }",
        "metadata": {
          "impact": "moderate",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Elements implicit ARIA role is an appropriate fallback';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Elements implicit ARIA role is not a good fallback for the (unsupported) role';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "aria-hidden-body",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return node.getAttribute('aria-hidden') !== 'true';\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'No aria-hidden attribute is present on document body';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'aria-hidden=true should not be present on the document body';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "aria-required-attr",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = options || {};\n        var missing = [];\n        if (node.hasAttributes()) {\n          var attr, role = node.getAttribute('role'), required = axe.commons.aria.requiredAttr(role);\n          if (Array.isArray(options[role])) {\n            required = axe.utils.uniqueArray(options[role], required);\n          }\n          if (role && required) {\n            for (var i = 0, l = required.length; i < l; i++) {\n              attr = required[i];\n              if (!node.getAttribute(attr)) {\n                missing.push(attr);\n              }\n            }\n          }\n        }\n        if (missing.length) {\n          this.data(missing);\n          return false;\n        }\n        return true;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'All required ARIA attributes are present';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Required ARIA attribute' + (it.data && it.data.length > 1 ? 's' : '') + ' not present:';\n              var arr1 = it.data;\n              if (arr1) {\n                var value, i1 = -1, l1 = arr1.length - 1;\n                while (i1 < l1) {\n                  value = arr1[i1 += 1];\n                  out += ' ' + value;\n                }\n              }\n              return out;\n            }"
          }
        }
      },
      {
        "id": "aria-required-children",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var requiredOwned = axe.commons.aria.requiredOwned;\n        var implicitNodes = axe.commons.aria.implicitNodes;\n        var matchesSelector = axe.commons.utils.matchesSelector;\n        var idrefs = axe.commons.dom.idrefs;\n        var reviewEmpty = options && Array.isArray(options.reviewEmpty) ? options.reviewEmpty : [];\n        function owns(node, virtualTree, role, ariaOwned) {\n          if (node === null) {\n            return false;\n          }\n          var implicit = implicitNodes(role), selector = [ '[role=\"' + role + '\"]' ];\n          if (implicit) {\n            selector = selector.concat(implicit);\n          }\n          selector = selector.join(',');\n          return ariaOwned ? matchesSelector(node, selector) || !!axe.utils.querySelectorAll(virtualTree, selector)[0] : !!axe.utils.querySelectorAll(virtualTree, selector)[0];\n        }\n        function ariaOwns(nodes, role) {\n          var index, length;\n          for (index = 0, length = nodes.length; index < length; index++) {\n            if (nodes[index] === null) {\n              continue;\n            }\n            var virtualTree = axe.utils.getNodeFromTree(axe._tree[0], nodes[index]);\n            if (owns(nodes[index], virtualTree, role, true)) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function missingRequiredChildren(node, childRoles, all, role) {\n          var i, l = childRoles.length, missing = [], ownedElements = idrefs(node, 'aria-owns');\n          for (i = 0; i < l; i++) {\n            var r = childRoles[i];\n            if (owns(node, virtualNode, r) || ariaOwns(ownedElements, r)) {\n              if (!all) {\n                return null;\n              }\n            } else {\n              if (all) {\n                missing.push(r);\n              }\n            }\n          }\n          if (role === 'combobox') {\n            var textboxIndex = missing.indexOf('textbox');\n            var textTypeInputs = [ 'text', 'search', 'email', 'url', 'tel' ];\n            if (textboxIndex >= 0 && node.tagName === 'INPUT' && textTypeInputs.includes(node.type)) {\n              missing.splice(textboxIndex, 1);\n            }\n            var listboxIndex = missing.indexOf('listbox');\n            var expanded = node.getAttribute('aria-expanded');\n            if (listboxIndex >= 0 && (!expanded || expanded === 'false')) {\n              missing.splice(listboxIndex, 1);\n            }\n          }\n          if (missing.length) {\n            return missing;\n          }\n          if (!all && childRoles.length) {\n            return childRoles;\n          }\n          return null;\n        }\n        var role = node.getAttribute('role');\n        var required = requiredOwned(role);\n        if (!required) {\n          return true;\n        }\n        var all = false;\n        var childRoles = required.one;\n        if (!childRoles) {\n          var all = true;\n          childRoles = required.all;\n        }\n        var missing = missingRequiredChildren(node, childRoles, all, role);\n        if (!missing) {\n          return true;\n        }\n        this.data(missing);\n        if (reviewEmpty.includes(role)) {\n          return undefined;\n        } else {\n          return false;\n        }\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Required ARIA children are present';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Required ARIA ' + (it.data && it.data.length > 1 ? 'children' : 'child') + ' role not present:';\n              var arr1 = it.data;\n              if (arr1) {\n                var value, i1 = -1, l1 = arr1.length - 1;\n                while (i1 < l1) {\n                  value = arr1[i1 += 1];\n                  out += ' ' + value;\n                }\n              }\n              return out;\n            }",
            "incomplete": "function anonymous(it) {\n              var out = 'Expecting ARIA ' + (it.data && it.data.length > 1 ? 'children' : 'child') + ' role to be added:';\n              var arr1 = it.data;\n              if (arr1) {\n                var value, i1 = -1, l1 = arr1.length - 1;\n                while (i1 < l1) {\n                  value = arr1[i1 += 1];\n                  out += ' ' + value;\n                }\n              }\n              return out;\n            }"
          }
        }
      },
      {
        "id": "aria-required-parent",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        function getSelector(role) {\n          var impliedNative = axe.commons.aria.implicitNodes(role) || [];\n          return impliedNative.concat('[role=\"' + role + '\"]').join(',');\n        }\n        function getMissingContext(virtualNode, requiredContext, includeElement) {\n          var index, length, role = virtualNode.actualNode.getAttribute('role'), missing = [];\n          if (!requiredContext) {\n            requiredContext = axe.commons.aria.requiredContext(role);\n          }\n          if (!requiredContext) {\n            return null;\n          }\n          for (index = 0, length = requiredContext.length; index < length; index++) {\n            if (includeElement && axe.utils.matchesSelector(virtualNode.actualNode, getSelector(requiredContext[index]))) {\n              return null;\n            }\n            if (axe.commons.dom.findUpVirtual(virtualNode, getSelector(requiredContext[index]))) {\n              return null;\n            } else {\n              missing.push(requiredContext[index]);\n            }\n          }\n          return missing;\n        }\n        function getAriaOwners(element) {\n          var owners = [], o = null;\n          while (element) {\n            if (element.getAttribute('id')) {\n              var id = axe.commons.utils.escapeSelector(element.getAttribute('id'));\n              var doc = axe.commons.dom.getRootNode(element);\n              o = doc.querySelector('[aria-owns~=' + id + ']');\n              if (o) {\n                owners.push(o);\n              }\n            }\n            element = element.parentElement;\n          }\n          return owners.length ? owners : null;\n        }\n        var missingParents = getMissingContext(virtualNode);\n        if (!missingParents) {\n          return true;\n        }\n        var owners = getAriaOwners(node);\n        if (owners) {\n          for (var i = 0, l = owners.length; i < l; i++) {\n            missingParents = getMissingContext(axe.utils.getNodeFromTree(axe._tree[0], owners[i]), missingParents, true);\n            if (!missingParents) {\n              return true;\n            }\n          }\n        }\n        this.data(missingParents);\n        return false;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Required ARIA parent role present';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Required ARIA parent' + (it.data && it.data.length > 1 ? 's' : '') + ' role not present:';\n              var arr1 = it.data;\n              if (arr1) {\n                var value, i1 = -1, l1 = arr1.length - 1;\n                while (i1 < l1) {\n                  value = arr1[i1 += 1];\n                  out += ' ' + value;\n                }\n              }\n              return out;\n            }"
          }
        }
      },
      {
        "id": "invalidrole",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return !axe.commons.aria.isValidRole(node.getAttribute('role'), {\n          allowAbstract: true\n        });\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'ARIA role is valid';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Role must be one of the valid ARIA roles';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "abstractrole",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return axe.commons.aria.getRoleType(node.getAttribute('role')) === 'abstract';\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Abstract roles are not used';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Abstract roles cannot be directly used';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "unsupportedrole",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return !axe.commons.aria.isValidRole(node.getAttribute('role'), {\n          flagUnsupported: true\n        });\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'ARIA role is supported';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'The role used is not widely supported in assistive technologies';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "aria-valid-attr-value",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = Array.isArray(options) ? options : [];\n        var invalid = [], aria = /^aria-/;\n        var attr, attrName, attrs = node.attributes;\n        var skipAttrs = [ 'aria-errormessage' ];\n        for (var i = 0, l = attrs.length; i < l; i++) {\n          attr = attrs[i];\n          attrName = attr.name;\n          if (!skipAttrs.includes(attrName)) {\n            if (options.indexOf(attrName) === -1 && aria.test(attrName) && !axe.commons.aria.validateAttrValue(node, attrName)) {\n              invalid.push(attrName + '=\"' + attr.nodeValue + '\"');\n            }\n          }\n        }\n        if (invalid.length) {\n          this.data(invalid);\n          return false;\n        }\n        return true;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'ARIA attribute values are valid';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Invalid ARIA attribute value' + (it.data && it.data.length > 1 ? 's' : '') + ':';\n              var arr1 = it.data;\n              if (arr1) {\n                var value, i1 = -1, l1 = arr1.length - 1;\n                while (i1 < l1) {\n                  value = arr1[i1 += 1];\n                  out += ' ' + value;\n                }\n              }\n              return out;\n            }"
          }
        }
      },
      {
        "id": "aria-errormessage",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = Array.isArray(options) ? options : [];\n        var attr = node.getAttribute('aria-errormessage'), hasAttr = node.hasAttribute('aria-errormessage');\n        var doc = axe.commons.dom.getRootNode(node);\n        function validateAttrValue() {\n          var idref = attr && doc.getElementById(attr);\n          if (idref) {\n            return idref.getAttribute('role') === 'alert' || idref.getAttribute('aria-live') === 'assertive' || axe.utils.tokenList(node.getAttribute('aria-describedby') || '').indexOf(attr) > -1;\n          }\n        }\n        if (options.indexOf(attr) === -1 && hasAttr) {\n          if (!validateAttrValue()) {\n            this.data(axe.utils.tokenList(attr));\n            return false;\n          }\n        }\n        return true;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Uses a supported aria-errormessage technique';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'aria-errormessage value' + (it.data && it.data.length > 1 ? 's' : '') + ' ';\n              var arr1 = it.data;\n              if (arr1) {\n                var value, i1 = -1, l1 = arr1.length - 1;\n                while (i1 < l1) {\n                  value = arr1[i1 += 1];\n                  out += ' `' + value;\n                }\n              }\n              out += '` must use a technique to announce the message (e.g., aria-live, aria-describedby, role=alert, etc.)';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "aria-valid-attr",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = Array.isArray(options) ? options : [];\n        var invalid = [], aria = /^aria-/;\n        var attr, attrs = node.attributes;\n        for (var i = 0, l = attrs.length; i < l; i++) {\n          attr = attrs[i].name;\n          if (options.indexOf(attr) === -1 && aria.test(attr) && !axe.commons.aria.validateAttr(attr)) {\n            invalid.push(attr);\n          }\n        }\n        if (invalid.length) {\n          this.data(invalid);\n          return false;\n        }\n        return true;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'ARIA attribute name' + (it.data && it.data.length > 1 ? 's' : '') + ' are valid';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Invalid ARIA attribute name' + (it.data && it.data.length > 1 ? 's' : '') + ':';\n              var arr1 = it.data;\n              if (arr1) {\n                var value, i1 = -1, l1 = arr1.length - 1;\n                while (i1 < l1) {\n                  value = arr1[i1 += 1];\n                  out += ' ' + value;\n                }\n              }\n              return out;\n            }"
          }
        }
      },
      {
        "id": "caption",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tracks = axe.utils.querySelectorAll(virtualNode, 'track');\n        var hasCaptions = tracks.some(function(_ref6) {\n          var actualNode = _ref6.actualNode;\n          return (actualNode.getAttribute('kind') || '').toLowerCase() === 'captions';\n        });\n        return hasCaptions ? false : undefined;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'The multimedia element has a captions track';\n              return out;\n            }",
            "incomplete": "function anonymous(it) {\n              var out = 'Check that captions is available for the element';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "autocomplete-valid",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var autocomplete = node.getAttribute('autocomplete') || '';\n        return axe.commons.text.isValidAutocomplete(autocomplete, options);\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'the autocomplete attribute is correctly formatted';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'the autocomplete attribute is incorrectly formatted';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "autocomplete-appropriate",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (node.nodeName.toUpperCase() !== 'INPUT') {\n          return true;\n        }\n        var number = [ 'text', 'search', 'number' ];\n        var url = [ 'text', 'search', 'url' ];\n        var allowedTypesMap = {\n          bday: [ 'text', 'search', 'date' ],\n          email: [ 'text', 'search', 'email' ],\n          'cc-exp': [ 'text', 'search', 'month' ],\n          'street-address': [],\n          tel: [ 'text', 'search', 'tel' ],\n          'cc-exp-month': number,\n          'cc-exp-year': number,\n          'transaction-amount': number,\n          'bday-day': number,\n          'bday-month': number,\n          'bday-year': number,\n          'new-password': [ 'text', 'search', 'password' ],\n          'current-password': [ 'text', 'search', 'password' ],\n          url: url,\n          photo: url,\n          impp: url\n        };\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n          Object.keys(options).forEach(function(key) {\n            if (!allowedTypesMap[key]) {\n              allowedTypesMap[key] = [];\n            }\n            allowedTypesMap[key] = allowedTypesMap[key].concat(options[key]);\n          });\n        }\n        var autocomplete = node.getAttribute('autocomplete');\n        var autocompleteTerms = autocomplete.split(/\\s+/g).map(function(term) {\n          return term.toLowerCase();\n        });\n        var purposeTerm = autocompleteTerms[autocompleteTerms.length - 1];\n        if (axe.commons.text.autocomplete.stateTerms.includes(purposeTerm)) {\n          return true;\n        }\n        var allowedTypes = allowedTypesMap[purposeTerm];\n        if (typeof allowedTypes === 'undefined') {\n          return node.type === 'text';\n        }\n        return allowedTypes.includes(node.type);\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'the autocomplete value is on an appropriate element';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'the autocomplete value is inappropriate for this type of input';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "is-on-screen",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return axe.commons.dom.isVisible(node, false) && !axe.commons.dom.isOffscreen(node);\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element is not visible';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element is visible';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "non-empty-if-present",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var nodeName = node.nodeName.toUpperCase();\n        var type = (node.getAttribute('type') || '').toLowerCase();\n        var label = node.getAttribute('value');\n        this.data(label);\n        if (nodeName === 'INPUT' && [ 'submit', 'reset' ].includes(type)) {\n          return label === null;\n        }\n        return false;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element ';\n              if (it.data) {\n                out += 'has a non-empty value attribute';\n              } else {\n                out += 'does not have a value attribute';\n              }\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element has a value attribute and the value attribute is empty';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "non-empty-value",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var label = node.getAttribute('value');\n        return !!(label ? axe.commons.text.sanitize(label).trim() : '');\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element has a non-empty value attribute';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element has no value attribute or the value attribute is empty';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "button-has-visible-text",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var nodeName = node.nodeName.toUpperCase();\n        var role = node.getAttribute('role');\n        var label = void 0;\n        if (nodeName === 'BUTTON' || role === 'button' && nodeName !== 'INPUT') {\n          label = axe.commons.text.accessibleTextVirtual(virtualNode);\n          this.data(label);\n          return !!label;\n        } else {\n          return false;\n        }\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element has inner text that is visible to screen readers';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element does not have inner text that is visible to screen readers';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "role-presentation",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return node.getAttribute('role') === 'presentation';\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element\\'s default semantics were overriden with role=\"presentation\"';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element\\'s default semantics were not overridden with role=\"presentation\"';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "role-none",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return node.getAttribute('role') === 'none';\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element\\'s default semantics were overriden with role=\"none\"';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element\\'s default semantics were not overridden with role=\"none\"';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "focusable-no-name",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tabIndex = node.getAttribute('tabindex'), inFocusOrder = axe.commons.dom.isFocusable(node) && tabIndex > -1;\n        if (!inFocusOrder) {\n          return false;\n        }\n        return !axe.commons.text.accessibleTextVirtual(virtualNode);\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element is not in tab order or has accessible text';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element is in tab order and does not have accessible text';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "internal-link-present",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var links = axe.utils.querySelectorAll(virtualNode, 'a[href]');\n        return links.some(function(vLink) {\n          return /^#[^/!]/.test(vLink.actualNode.getAttribute('href'));\n        });\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Valid skip link found';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'No valid skip link found';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "header-present",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return !!axe.utils.querySelectorAll(virtualNode, 'h1, h2, h3, h4, h5, h6, [role=\"heading\"]')[0];\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Page has a header';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Page does not have a header';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "landmark",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return axe.utils.querySelectorAll(virtualNode, 'main, [role=\"main\"]').length > 0;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Page has a landmark region';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Page does not have a landmark region';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "group-labelledby",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        this.data({\n          name: node.getAttribute('name'),\n          type: node.getAttribute('type')\n        });\n        var doc = axe.commons.dom.getRootNode(node);\n        var matchingNodes = doc.querySelectorAll('input[type=\"' + axe.commons.utils.escapeSelector(node.type) + '\"][name=\"' + axe.commons.utils.escapeSelector(node.name) + '\"]');\n        if (matchingNodes.length <= 1) {\n          return true;\n        }\n        return [].map.call(matchingNodes, function(m) {\n          var l = m.getAttribute('aria-labelledby');\n          return l ? l.split(/\\s+/) : [];\n        }).reduce(function(prev, curr) {\n          return prev.filter(function(n) {\n            return curr.includes(n);\n          });\n        }).filter(function(n) {\n          var labelNode = doc.getElementById(n);\n          return labelNode && axe.commons.text.accessibleText(labelNode, true);\n        }).length !== 0;\n      }",
        "after": "function after(results, options) {\n        var seen = {};\n        return results.filter(function(result) {\n          var data = result.data;\n          if (data) {\n            seen[data.type] = seen[data.type] || {};\n            if (!seen[data.type][data.name]) {\n              seen[data.type][data.name] = true;\n              return true;\n            }\n          }\n          return false;\n        });\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'All elements with the name \"' + it.data.name + '\" reference the same element with aria-labelledby';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'All elements with the name \"' + it.data.name + '\" do not reference the same element with aria-labelledby';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "fieldset",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var failureCode, self = this;\n        function getUnrelatedElements(parent, name) {\n          return axe.commons.utils.toArray(parent.querySelectorAll('select,textarea,button,input:not([name=\"' + name + '\"]):not([type=\"hidden\"])'));\n        }\n        function checkFieldset(group, name) {\n          var firstNode = group.firstElementChild;\n          if (!firstNode || firstNode.nodeName.toUpperCase() !== 'LEGEND') {\n            self.relatedNodes([ group ]);\n            failureCode = 'no-legend';\n            return false;\n          }\n          if (!axe.commons.text.accessibleText(firstNode)) {\n            self.relatedNodes([ firstNode ]);\n            failureCode = 'empty-legend';\n            return false;\n          }\n          var otherElements = getUnrelatedElements(group, name);\n          if (otherElements.length) {\n            self.relatedNodes(otherElements);\n            failureCode = 'mixed-inputs';\n            return false;\n          }\n          return true;\n        }\n        function checkARIAGroup(group, name) {\n          var hasLabelledByText = axe.commons.dom.idrefs(group, 'aria-labelledby').some(function(element) {\n            return element && axe.commons.text.accessibleText(element);\n          });\n          var ariaLabel = group.getAttribute('aria-label');\n          if (!hasLabelledByText && !(ariaLabel && axe.commons.text.sanitize(ariaLabel))) {\n            self.relatedNodes(group);\n            failureCode = 'no-group-label';\n            return false;\n          }\n          var otherElements = getUnrelatedElements(group, name);\n          if (otherElements.length) {\n            self.relatedNodes(otherElements);\n            failureCode = 'group-mixed-inputs';\n            return false;\n          }\n          return true;\n        }\n        function spliceCurrentNode(nodes, current) {\n          return axe.commons.utils.toArray(nodes).filter(function(candidate) {\n            return candidate !== current;\n          });\n        }\n        function runCheck(virtualNode) {\n          var name = axe.commons.utils.escapeSelector(virtualNode.actualNode.name);\n          var root = axe.commons.dom.getRootNode(virtualNode.actualNode);\n          var matchingNodes = root.querySelectorAll('input[type=\"' + axe.commons.utils.escapeSelector(virtualNode.actualNode.type) + '\"][name=\"' + name + '\"]');\n          if (matchingNodes.length < 2) {\n            return true;\n          }\n          var fieldset = axe.commons.dom.findUpVirtual(virtualNode, 'fieldset');\n          var group = axe.commons.dom.findUpVirtual(virtualNode, '[role=\"group\"]' + (virtualNode.actualNode.type === 'radio' ? ',[role=\"radiogroup\"]' : ''));\n          if (!group && !fieldset) {\n            failureCode = 'no-group';\n            self.relatedNodes(spliceCurrentNode(matchingNodes, virtualNode.actualNode));\n            return false;\n          } else if (fieldset) {\n            return checkFieldset(fieldset, name);\n          } else {\n            return checkARIAGroup(group, name);\n          }\n        }\n        var data = {\n          name: node.getAttribute('name'),\n          type: node.getAttribute('type')\n        };\n        var result = runCheck(virtualNode);\n        if (!result) {\n          data.failureCode = failureCode;\n        }\n        this.data(data);\n        return result;\n      }",
        "after": "function after(results, options) {\n        var seen = {};\n        return results.filter(function(result) {\n          if (result.result) {\n            return true;\n          }\n          var data = result.data;\n          if (data) {\n            seen[data.type] = seen[data.type] || {};\n            if (!seen[data.type][data.name]) {\n              seen[data.type][data.name] = [ data ];\n              return true;\n            }\n            var hasBeenSeen = seen[data.type][data.name].some(function(candidate) {\n              return candidate.failureCode === data.failureCode;\n            });\n            if (!hasBeenSeen) {\n              seen[data.type][data.name].push(data);\n            }\n            return !hasBeenSeen;\n          }\n          return false;\n        });\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element is contained in a fieldset';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = '';\n              var code = it.data && it.data.failureCode;\n              if (code === 'no-legend') {\n                out += 'Fieldset does not have a legend as its first child';\n              } else if (code === 'empty-legend') {\n                out += 'Legend does not have text that is visible to screen readers';\n              } else if (code === 'mixed-inputs') {\n                out += 'Fieldset contains unrelated inputs';\n              } else if (code === 'no-group-label') {\n                out += 'ARIA group does not have aria-label or aria-labelledby';\n              } else if (code === 'group-mixed-inputs') {\n                out += 'ARIA group contains unrelated inputs';\n              } else {\n                out += 'Element does not have a containing fieldset or ARIA group';\n              }\n              return out;\n            }"
          }
        }
      },
      {
        "id": "color-contrast",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons4 = axe.commons, dom = _axe$commons4.dom, color = _axe$commons4.color, text = _axe$commons4.text;\n        if (!dom.isVisible(node, false)) {\n          return true;\n        }\n        var noScroll = !!(options || {}).noScroll;\n        var bgNodes = [];\n        var bgColor = color.getBackgroundColor(node, bgNodes, noScroll);\n        var fgColor = color.getForegroundColor(node, noScroll);\n        var nodeStyle = window.getComputedStyle(node);\n        var fontSize = parseFloat(nodeStyle.getPropertyValue('font-size'));\n        var fontWeight = nodeStyle.getPropertyValue('font-weight');\n        var bold = [ 'bold', 'bolder', '600', '700', '800', '900' ].indexOf(fontWeight) !== -1;\n        var cr = color.hasValidContrastRatio(bgColor, fgColor, fontSize, bold);\n        var truncatedResult = Math.floor(cr.contrastRatio * 100) / 100;\n        var missing = void 0;\n        if (bgColor === null) {\n          missing = color.incompleteData.get('bgColor');\n        }\n        var equalRatio = truncatedResult === 1;\n        var shortTextContent = text.visibleVirtual(virtualNode, false, true).length === 1;\n        if (equalRatio) {\n          missing = color.incompleteData.set('bgColor', 'equalRatio');\n        } else if (shortTextContent) {\n          missing = 'shortTextContent';\n        }\n        var data = {\n          fgColor: fgColor ? fgColor.toHexString() : undefined,\n          bgColor: bgColor ? bgColor.toHexString() : undefined,\n          contrastRatio: cr ? truncatedResult : undefined,\n          fontSize: (fontSize * 72 / 96).toFixed(1) + 'pt',\n          fontWeight: bold ? 'bold' : 'normal',\n          missingData: missing,\n          expectedContrastRatio: cr.expectedContrastRatio + ':1'\n        };\n        this.data(data);\n        if (fgColor === null || bgColor === null || equalRatio || shortTextContent && !cr.isValid) {\n          missing = null;\n          color.incompleteData.clear();\n          this.relatedNodes(bgNodes);\n          return undefined;\n        }\n        if (!cr.isValid) {\n          this.relatedNodes(bgNodes);\n        }\n        return cr.isValid;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element has sufficient color contrast of ' + it.data.contrastRatio;\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element has insufficient color contrast of ' + it.data.contrastRatio + ' (foreground color: ' + it.data.fgColor + ', background color: ' + it.data.bgColor + ', font size: ' + it.data.fontSize + ', font weight: ' + it.data.fontWeight + '). Expected contrast ratio of ' + it.data.expectedContrastRatio;\n              return out;\n            }",
            "incomplete": {
              "bgImage": "Element's background color could not be determined due to a background image",
              "bgGradient": "Element's background color could not be determined due to a background gradient",
              "imgNode": "Element's background color could not be determined because element contains an image node",
              "bgOverlap": "Element's background color could not be determined because it is overlapped by another element",
              "fgAlpha": "Element's foreground color could not be determined because of alpha transparency",
              "elmPartiallyObscured": "Element's background color could not be determined because it's partially obscured by another element",
              "elmPartiallyObscuring": "Element's background color could not be determined because it partially overlaps other elements",
              "outsideViewport": "Element's background color could not be determined because it's outside the viewport",
              "equalRatio": "Element has a 1:1 contrast ratio with the background",
              "shortTextContent": "Element content is too short to determine if it is actual text content",
              "default": "Unable to determine contrast ratio"
            }
          }
        }
      },
      {
        "id": "css-orientation-lock",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _ref8 = context || {}, _ref8$cssom = _ref8.cssom, cssom = _ref8$cssom === undefined ? undefined : _ref8$cssom;\n        if (!cssom || !cssom.length) {\n          return undefined;\n        }\n        var rulesGroupByDocumentFragment = cssom.reduce(function(out, _ref9) {\n          var sheet = _ref9.sheet, root = _ref9.root, shadowId = _ref9.shadowId;\n          var key = shadowId ? shadowId : 'topDocument';\n          if (!out[key]) {\n            out[key] = {\n              root: root,\n              rules: []\n            };\n          }\n          if (!sheet || !sheet.cssRules) {\n            return out;\n          }\n          var rules = Array.from(sheet.cssRules);\n          out[key].rules = out[key].rules.concat(rules);\n          return out;\n        }, {});\n        var isLocked = false;\n        var relatedElements = [];\n        Object.keys(rulesGroupByDocumentFragment).forEach(function(key) {\n          var _rulesGroupByDocument = rulesGroupByDocumentFragment[key], root = _rulesGroupByDocument.root, rules = _rulesGroupByDocument.rules;\n          var mediaRules = rules.filter(function(r) {\n            return r.type === 4;\n          });\n          if (!mediaRules || !mediaRules.length) {\n            return;\n          }\n          var orientationRules = mediaRules.filter(function(r) {\n            var cssText = r.cssText;\n            return /orientation:\\s+landscape/i.test(cssText) || /orientation:\\s+portrait/i.test(cssText);\n          });\n          if (!orientationRules || !orientationRules.length) {\n            return;\n          }\n          orientationRules.forEach(function(r) {\n            if (!r.cssRules.length) {\n              return;\n            }\n            Array.from(r.cssRules).forEach(function(cssRule) {\n              if (!cssRule.selectorText) {\n                return;\n              }\n              if (cssRule.style.length <= 0) {\n                return;\n              }\n              var transformStyleValue = cssRule.style.transform || false;\n              if (!transformStyleValue) {\n                return;\n              }\n              var rotate = transformStyleValue.match(/rotate\\(([^)]+)deg\\)/);\n              var deg = parseInt(rotate && rotate[1] || 0);\n              var locked = deg % 90 === 0 && deg % 180 !== 0;\n              if (locked && cssRule.selectorText.toUpperCase() !== 'HTML') {\n                var selector = cssRule.selectorText;\n                var elms = Array.from(root.querySelectorAll(selector));\n                if (elms && elms.length) {\n                  relatedElements = relatedElements.concat(elms);\n                }\n              }\n              isLocked = locked;\n            });\n          });\n        });\n        if (!isLocked) {\n          return true;\n        }\n        if (relatedElements.length) {\n          this.relatedNodes(relatedElements);\n        }\n        return false;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Display is operable, and orientation lock does not exist';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'CSS Orientation lock is applied, and makes display inoperable';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "structured-dlitems",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var children = virtualNode.children;\n        if (!children || !children.length) {\n          return false;\n        }\n        var hasDt = false, hasDd = false, nodeName;\n        for (var i = 0; i < children.length; i++) {\n          nodeName = children[i].actualNode.nodeName.toUpperCase();\n          if (nodeName === 'DT') {\n            hasDt = true;\n          }\n          if (hasDt && nodeName === 'DD') {\n            return false;\n          }\n          if (nodeName === 'DD') {\n            hasDd = true;\n          }\n        }\n        return hasDt || hasDd;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'When not empty, element has both <dt> and <dd> elements';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'When not empty, element does not have at least one <dt> element followed by at least one <dd> element';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "only-dlitems",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons6 = axe.commons, dom = _axe$commons6.dom, aria = _axe$commons6.aria;\n        var ALLOWED_ROLES = [ 'definition', 'term', 'list' ];\n        var base = {\n          badNodes: [],\n          hasNonEmptyTextNode: false\n        };\n        var content = virtualNode.children.reduce(function(content, child) {\n          var actualNode = child.actualNode;\n          if (actualNode.nodeName.toUpperCase() === 'DIV' && aria.getRole(actualNode) === null) {\n            return content.concat(child.children);\n          }\n          return content.concat(child);\n        }, []);\n        var result = content.reduce(function(out, childNode) {\n          var actualNode = childNode.actualNode;\n          var tagName = actualNode.nodeName.toUpperCase();\n          if (actualNode.nodeType === 1 && dom.isVisible(actualNode, true, false)) {\n            var explicitRole = aria.getRole(actualNode, {\n              noImplicit: true\n            });\n            if (tagName !== 'DT' && tagName !== 'DD' || explicitRole) {\n              if (!ALLOWED_ROLES.includes(explicitRole)) {\n                out.badNodes.push(actualNode);\n              }\n            }\n          } else if (actualNode.nodeType === 3 && actualNode.nodeValue.trim() !== '') {\n            out.hasNonEmptyTextNode = true;\n          }\n          return out;\n        }, base);\n        if (result.badNodes.length) {\n          this.relatedNodes(result.badNodes);\n        }\n        return !!result.badNodes.length || result.hasNonEmptyTextNode;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'List element only has direct children that are allowed inside <dt> or <dd> elements';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'List element has direct children that are not allowed inside <dt> or <dd> elements';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "dlitem",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var parent = axe.commons.dom.getComposedParent(node);\n        var parentTagName = parent.nodeName.toUpperCase();\n        if (parentTagName !== 'DL') {\n          return false;\n        }\n        var parentRole = (parent.getAttribute('role') || '').toLowerCase();\n        if (!parentRole || !axe.commons.aria.isValidRole(parentRole)) {\n          return true;\n        }\n        if (parentRole === 'list') {\n          return true;\n        }\n        return false;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Description list item has a <dl> parent element';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Description list item does not have a <dl> parent element';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "doc-has-title",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var title = document.title;\n        return !!(title ? axe.commons.text.sanitize(title).trim() : '');\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Document has a non-empty <title> element';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Document does not have a non-empty <title> element';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "duplicate-id-active",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var id = node.getAttribute('id').trim();\n        if (!id) {\n          return true;\n        }\n        var root = axe.commons.dom.getRootNode(node);\n        var matchingNodes = Array.from(root.querySelectorAll('[id=\"' + axe.commons.utils.escapeSelector(id) + '\"]')).filter(function(foundNode) {\n          return foundNode !== node;\n        });\n        if (matchingNodes.length) {\n          this.relatedNodes(matchingNodes);\n        }\n        this.data(id);\n        return matchingNodes.length === 0;\n      }",
        "after": "function after(results, options) {\n        var uniqueIds = [];\n        return results.filter(function(r) {\n          if (uniqueIds.indexOf(r.data) === -1) {\n            uniqueIds.push(r.data);\n            return true;\n          }\n          return false;\n        });\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Document has no active elements that share the same id attribute';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Document has active elements with the same id attribute: ' + it.data;\n              return out;\n            }"
          }
        }
      },
      {
        "id": "duplicate-id-aria",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var id = node.getAttribute('id').trim();\n        if (!id) {\n          return true;\n        }\n        var root = axe.commons.dom.getRootNode(node);\n        var matchingNodes = Array.from(root.querySelectorAll('[id=\"' + axe.commons.utils.escapeSelector(id) + '\"]')).filter(function(foundNode) {\n          return foundNode !== node;\n        });\n        if (matchingNodes.length) {\n          this.relatedNodes(matchingNodes);\n        }\n        this.data(id);\n        return matchingNodes.length === 0;\n      }",
        "after": "function after(results, options) {\n        var uniqueIds = [];\n        return results.filter(function(r) {\n          if (uniqueIds.indexOf(r.data) === -1) {\n            uniqueIds.push(r.data);\n            return true;\n          }\n          return false;\n        });\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Document has no elements referenced with ARIA or labels that share the same id attribute';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Document has multiple elements referenced with ARIA with the same id attribute: ' + it.data;\n              return out;\n            }"
          }
        }
      },
      {
        "id": "duplicate-id",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var id = node.getAttribute('id').trim();\n        if (!id) {\n          return true;\n        }\n        var root = axe.commons.dom.getRootNode(node);\n        var matchingNodes = Array.from(root.querySelectorAll('[id=\"' + axe.commons.utils.escapeSelector(id) + '\"]')).filter(function(foundNode) {\n          return foundNode !== node;\n        });\n        if (matchingNodes.length) {\n          this.relatedNodes(matchingNodes);\n        }\n        this.data(id);\n        return matchingNodes.length === 0;\n      }",
        "after": "function after(results, options) {\n        var uniqueIds = [];\n        return results.filter(function(r) {\n          if (uniqueIds.indexOf(r.data) === -1) {\n            uniqueIds.push(r.data);\n            return true;\n          }\n          return false;\n        });\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Document has no static elements that share the same id attribute';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Document has multiple static elements with the same id attribute';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "has-visible-text",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return axe.commons.text.accessibleTextVirtual(virtualNode).length > 0;\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element has text that is visible to screen readers';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element does not have text that is visible to screen readers';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "has-widget-role",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var role = node.getAttribute('role');\n        if (role === null) {\n          return false;\n        }\n        var roleType = axe.commons.aria.getRoleType(role);\n        return roleType === 'widget' || roleType === 'composite';\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element has a widget role.';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element does not have a widget role.';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "valid-scrollable-semantics",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var VALID_TAG_NAMES_FOR_SCROLLABLE_REGIONS = {\n          ARTICLE: true,\n          ASIDE: true,\n          NAV: true,\n          SECTION: true\n        };\n        var VALID_ROLES_FOR_SCROLLABLE_REGIONS = {\n          application: true,\n          banner: false,\n          complementary: true,\n          contentinfo: true,\n          form: true,\n          main: true,\n          navigation: true,\n          region: true,\n          search: false\n        };\n        function validScrollableTagName(node) {\n          var tagName = node.tagName.toUpperCase();\n          return VALID_TAG_NAMES_FOR_SCROLLABLE_REGIONS[tagName] || false;\n        }\n        function validScrollableRole(node) {\n          var role = node.getAttribute('role');\n          if (!role) {\n            return false;\n          }\n          return VALID_ROLES_FOR_SCROLLABLE_REGIONS[role.toLowerCase()] || false;\n        }\n        function validScrollableSemantics(node) {\n          return validScrollableRole(node) || validScrollableTagName(node);\n        }\n        return validScrollableSemantics(node);\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element has valid semantics for an element in the focus order.';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element has invalid semantics for an element in the focus order.';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "frame-tested",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var resolve = this.async();\n        var _Object$assign = Object.assign({\n          isViolation: false,\n          timeout: 500\n        }, options), isViolation = _Object$assign.isViolation, timeout = _Object$assign.timeout;\n        var timer = setTimeout(function() {\n          timer = setTimeout(function() {\n            timer = null;\n            resolve(isViolation ? false : undefined);\n          }, 0);\n        }, timeout);\n        axe.utils.respondable(node.contentWindow, 'axe.ping', null, undefined, function() {\n          if (timer !== null) {\n            clearTimeout(timer);\n            resolve(true);\n          }\n        });\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'The iframe was tested with axe-core';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'The iframe could not be tested with axe-core';\n              return out;\n            }",
            "incomplete": "function anonymous(it) {\n              var out = 'The iframe still has to be tested with axe-core';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "unique-frame-title",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var title = axe.commons.text.sanitize(node.title).trim().toLowerCase();\n        this.data(title);\n        return true;\n      }",
        "after": "function after(results, options) {\n        var titles = {};\n        results.forEach(function(r) {\n          titles[r.data] = titles[r.data] !== undefined ? ++titles[r.data] : 0;\n        });\n        results.forEach(function(r) {\n          r.result = !!titles[r.data];\n        });\n        return results;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element\\'s title attribute is unique';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element\\'s title attribute is not unique';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "heading-order",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var ariaHeadingLevel = node.getAttribute('aria-level');\n        if (ariaHeadingLevel !== null) {\n          this.data(parseInt(ariaHeadingLevel, 10));\n          return true;\n        }\n        var headingLevel = node.tagName.match(/H(\\d)/);\n        if (headingLevel) {\n          this.data(parseInt(headingLevel[1], 10));\n          return true;\n        }\n        return true;\n      }",
        "after": "function after(results, options) {\n        if (results.length < 2) {\n          return results;\n        }\n        var prevLevel = results[0].data;\n        for (var i = 1; i < results.length; i++) {\n          if (results[i].result && results[i].data > prevLevel + 1) {\n            results[i].result = false;\n          }\n          prevLevel = results[i].data;\n        }\n        return results;\n      }",
        "metadata": {
          "impact": "moderate",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Heading order valid';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Heading order invalid';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "hidden-content",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var whitelist = [ 'SCRIPT', 'HEAD', 'TITLE', 'NOSCRIPT', 'STYLE', 'TEMPLATE' ];\n        if (!whitelist.includes(node.tagName.toUpperCase()) && axe.commons.dom.hasContentVirtual(virtualNode)) {\n          var styles = window.getComputedStyle(node);\n          if (styles.getPropertyValue('display') === 'none') {\n            return undefined;\n          } else if (styles.getPropertyValue('visibility') === 'hidden') {\n            var parent = axe.commons.dom.getComposedParent(node);\n            var parentStyle = parent && window.getComputedStyle(parent);\n            if (!parentStyle || parentStyle.getPropertyValue('visibility') !== 'hidden') {\n              return undefined;\n            }\n          }\n        }\n        return true;\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'All content on the page has been analyzed.';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'There were problems analyzing the content on this page.';\n              return out;\n            }",
            "incomplete": "function anonymous(it) {\n              var out = 'There is hidden content on the page that was not analyzed. You will need to trigger the display of this content in order to analyze it.';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "has-lang",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return !!(node.getAttribute('lang') || node.getAttribute('xml:lang') || '').trim();\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'The <html> element has a lang attribute';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'The <html> element does not have a lang attribute';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "valid-lang",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var langs, invalid;\n        langs = (options ? options : axe.commons.utils.validLangs()).map(axe.commons.utils.getBaseLang);\n        invalid = [ 'lang', 'xml:lang' ].reduce(function(invalid, langAttr) {\n          var langVal = node.getAttribute(langAttr);\n          if (typeof langVal !== 'string') {\n            return invalid;\n          }\n          var baselangVal = axe.commons.utils.getBaseLang(langVal);\n          if (baselangVal !== '' && langs.indexOf(baselangVal) === -1) {\n            invalid.push(langAttr + '=\"' + node.getAttribute(langAttr) + '\"');\n          }\n          return invalid;\n        }, []);\n        if (invalid.length) {\n          this.data(invalid);\n          return true;\n        }\n        return false;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Value of lang attribute is included in the list of valid languages';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Value of lang attribute not included in the list of valid languages';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "xml-lang-mismatch",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var getBaseLang = axe.commons.utils.getBaseLang;\n        var primaryLangValue = getBaseLang(node.getAttribute('lang'));\n        var primaryXmlLangValue = getBaseLang(node.getAttribute('xml:lang'));\n        return primaryLangValue === primaryXmlLangValue;\n      }",
        "metadata": {
          "impact": "moderate",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Lang and xml:lang attributes have the same base language';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Lang and xml:lang attributes do not have the same base language';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "has-alt",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var nn = node.nodeName.toLowerCase();\n        return node.hasAttribute('alt') && (nn === 'img' || nn === 'input' || nn === 'area');\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element has an alt attribute';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element does not have an alt attribute';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "duplicate-img-label",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var text = axe.commons.text.visibleVirtual(virtualNode, true).toLowerCase();\n        if (text === '') {\n          return false;\n        }\n        var images = axe.utils.querySelectorAll(virtualNode, 'img').filter(function(_ref2) {\n          var actualNode = _ref2.actualNode;\n          return axe.commons.dom.isVisible(actualNode) && ![ 'none', 'presentation' ].includes(actualNode.getAttribute('role'));\n        });\n        return images.some(function(img) {\n          return text === axe.commons.text.accessibleTextVirtual(img).toLowerCase();\n        });\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element does not duplicate existing text in <img> alt text';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element contains <img> element with alt text that duplicates existing text';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "title-only",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var labelText = axe.commons.text.labelVirtual(virtualNode);\n        return !labelText && !!(node.getAttribute('title') || node.getAttribute('aria-describedby'));\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Form element does not solely use title attribute for its label';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Only title used to generate label for form element';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "implicit-label",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var label = axe.commons.dom.findUpVirtual(virtualNode, 'label');\n        if (label) {\n          return !!axe.commons.text.accessibleTextVirtual(label);\n        }\n        return false;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Form element has an implicit (wrapped) <label>';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Form element does not have an implicit (wrapped) <label>';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "explicit-label",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (node.getAttribute('id')) {\n          var root = axe.commons.dom.getRootNode(node);\n          var id = axe.commons.utils.escapeSelector(node.getAttribute('id'));\n          var label = root.querySelector('label[for=\"' + id + '\"]');\n          if (label) {\n            if (!axe.commons.dom.isVisible(label)) {\n              return true;\n            } else {\n              return !!axe.commons.text.accessibleText(label);\n            }\n          }\n        }\n        return false;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Form element has an explicit <label>';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Form element does not have an explicit <label>';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "help-same-as-label",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var labelText = axe.commons.text.labelVirtual(virtualNode), check = node.getAttribute('title');\n        if (!labelText) {\n          return false;\n        }\n        if (!check) {\n          check = '';\n          if (node.getAttribute('aria-describedby')) {\n            var ref = axe.commons.dom.idrefs(node, 'aria-describedby');\n            check = ref.map(function(thing) {\n              return thing ? axe.commons.text.accessibleText(thing) : '';\n            }).join('');\n          }\n        }\n        return axe.commons.text.sanitize(check) === axe.commons.text.sanitize(labelText);\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Help text (title or aria-describedby) does not duplicate label text';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Help text (title or aria-describedby) text is the same as the label text';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "multiple-label",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var id = axe.commons.utils.escapeSelector(node.getAttribute('id'));\n        var labels = Array.from(document.querySelectorAll('label[for=\"' + id + '\"]'));\n        var parent = node.parentNode;\n        if (labels.length) {\n          labels = labels.filter(function(label, index) {\n            if (index === 0 && !axe.commons.dom.isVisible(label, true) || axe.commons.dom.isVisible(label, true)) {\n              return label;\n            }\n          });\n        }\n        while (parent) {\n          if (parent.tagName === 'LABEL' && labels.indexOf(parent) === -1) {\n            labels.push(parent);\n          }\n          parent = parent.parentNode;\n        }\n        this.relatedNodes(labels);\n        return labels.length > 1;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Form element does not have multiple <label> elements';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Form element has multiple <label> elements';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "hidden-explicit-label",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (node.getAttribute('id')) {\n          var root = axe.commons.dom.getRootNode(node);\n          var id = axe.commons.utils.escapeSelector(node.getAttribute('id'));\n          var label = root.querySelector('label[for=\"' + id + '\"]');\n          if (label && !axe.commons.dom.isVisible(label)) {\n            return true;\n          }\n        }\n        return false;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Form element has a visible explicit <label>';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Form element has explicit <label> that is hidden';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "landmark-is-top-level",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var landmarks = axe.commons.aria.getRolesByType('landmark');\n        var parent = axe.commons.dom.getComposedParent(node);\n        this.data({\n          role: node.getAttribute('role') || axe.commons.aria.implicitRole(node)\n        });\n        while (parent) {\n          var role = parent.getAttribute('role');\n          if (!role && parent.tagName.toLowerCase() !== 'form') {\n            role = axe.commons.aria.implicitRole(parent);\n          }\n          if (role && landmarks.includes(role)) {\n            return false;\n          }\n          parent = axe.commons.dom.getComposedParent(parent);\n        }\n        return true;\n      }",
        "metadata": {
          "impact": "moderate",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'The ' + it.data.role + ' landmark is at the top level.';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'The ' + it.data.role + ' landmark is contained in another landmark.';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "page-no-duplicate-banner",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!options || !options.selector || typeof options.selector !== 'string') {\n          throw new TypeError('visible-in-page requires options.selector to be a string');\n        }\n        var elms = axe.utils.querySelectorAll(virtualNode, options.selector);\n        if (typeof options.nativeScopeFilter === 'string') {\n          elms = elms.filter(function(elm) {\n            return elm.actualNode.hasAttribute('role') || !axe.commons.dom.findUpVirtual(elm, options.nativeScopeFilter);\n          });\n        }\n        this.relatedNodes(elms.map(function(elm) {\n          return elm.actualNode;\n        }));\n        return elms.length <= 1;\n      }",
        "metadata": {
          "impact": "moderate",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Document has no more than one banner landmark';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Document has more than one banner landmark';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "page-no-duplicate-contentinfo",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!options || !options.selector || typeof options.selector !== 'string') {\n          throw new TypeError('visible-in-page requires options.selector to be a string');\n        }\n        var elms = axe.utils.querySelectorAll(virtualNode, options.selector);\n        if (typeof options.nativeScopeFilter === 'string') {\n          elms = elms.filter(function(elm) {\n            return elm.actualNode.hasAttribute('role') || !axe.commons.dom.findUpVirtual(elm, options.nativeScopeFilter);\n          });\n        }\n        this.relatedNodes(elms.map(function(elm) {\n          return elm.actualNode;\n        }));\n        return elms.length <= 1;\n      }",
        "metadata": {
          "impact": "moderate",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Page does not have more than one contentinfo landmark';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Page has more than one contentinfo landmark';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "page-has-main",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!options || !options.selector || typeof options.selector !== 'string') {\n          throw new TypeError('visible-in-page requires options.selector to be a string');\n        }\n        var matchingElms = axe.utils.querySelectorAll(virtualNode, options.selector);\n        this.relatedNodes(matchingElms.map(function(vNode) {\n          return vNode.actualNode;\n        }));\n        return matchingElms.length > 0;\n      }",
        "after": "function after(results, options) {\n        var elmUsedAnywhere = results.some(function(frameResult) {\n          return frameResult.result === true;\n        });\n        if (elmUsedAnywhere) {\n          results.forEach(function(result) {\n            result.result = true;\n          });\n        }\n        return results;\n      }",
        "metadata": {
          "impact": "moderate",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Page has at least one main landmark';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Page does not have a main landmark';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "page-no-duplicate-main",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!options || !options.selector || typeof options.selector !== 'string') {\n          throw new TypeError('visible-in-page requires options.selector to be a string');\n        }\n        var elms = axe.utils.querySelectorAll(virtualNode, options.selector);\n        if (typeof options.nativeScopeFilter === 'string') {\n          elms = elms.filter(function(elm) {\n            return elm.actualNode.hasAttribute('role') || !axe.commons.dom.findUpVirtual(elm, options.nativeScopeFilter);\n          });\n        }\n        this.relatedNodes(elms.map(function(elm) {\n          return elm.actualNode;\n        }));\n        return elms.length <= 1;\n      }",
        "metadata": {
          "impact": "moderate",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Page does not have more than one main landmark';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Page has more than one main landmark';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "has-th",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var row, cell, badCells = [];\n        for (var rowIndex = 0, rowLength = node.rows.length; rowIndex < rowLength; rowIndex++) {\n          row = node.rows[rowIndex];\n          for (var cellIndex = 0, cellLength = row.cells.length; cellIndex < cellLength; cellIndex++) {\n            cell = row.cells[cellIndex];\n            if (cell.nodeName.toUpperCase() === 'TH' || [ 'rowheader', 'columnheader' ].indexOf(cell.getAttribute('role')) !== -1) {\n              badCells.push(cell);\n            }\n          }\n        }\n        if (badCells.length) {\n          this.relatedNodes(badCells);\n          return true;\n        }\n        return false;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Layout table does not use <th> elements';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Layout table uses <th> elements';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "has-caption",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return !!node.caption;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Layout table does not use <caption> element';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Layout table uses <caption> element';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "has-summary",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return !!node.summary;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Layout table does not use summary attribute';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Layout table uses summary attribute';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "link-in-text-block",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons5 = axe.commons, color = _axe$commons5.color, dom = _axe$commons5.dom;\n        function getContrast(color1, color2) {\n          var c1lum = color1.getRelativeLuminance();\n          var c2lum = color2.getRelativeLuminance();\n          return (Math.max(c1lum, c2lum) + .05) / (Math.min(c1lum, c2lum) + .05);\n        }\n        var blockLike = [ 'block', 'list-item', 'table', 'flex', 'grid', 'inline-block' ];\n        function isBlock(elm) {\n          var display = window.getComputedStyle(elm).getPropertyValue('display');\n          return blockLike.indexOf(display) !== -1 || display.substr(0, 6) === 'table-';\n        }\n        if (isBlock(node)) {\n          return false;\n        }\n        var parentBlock = dom.getComposedParent(node);\n        while (parentBlock.nodeType === 1 && !isBlock(parentBlock)) {\n          parentBlock = dom.getComposedParent(parentBlock);\n        }\n        this.relatedNodes([ parentBlock ]);\n        if (color.elementIsDistinct(node, parentBlock)) {\n          return true;\n        } else {\n          var nodeColor, parentColor;\n          nodeColor = color.getForegroundColor(node);\n          parentColor = color.getForegroundColor(parentBlock);\n          if (!nodeColor || !parentColor) {\n            return undefined;\n          }\n          var contrast = getContrast(nodeColor, parentColor);\n          if (contrast === 1) {\n            return true;\n          } else if (contrast >= 3) {\n            axe.commons.color.incompleteData.set('fgColor', 'bgContrast');\n            this.data({\n              missingData: axe.commons.color.incompleteData.get('fgColor')\n            });\n            axe.commons.color.incompleteData.clear();\n            return undefined;\n          }\n          nodeColor = color.getBackgroundColor(node);\n          parentColor = color.getBackgroundColor(parentBlock);\n          if (!nodeColor || !parentColor || getContrast(nodeColor, parentColor) >= 3) {\n            var reason = void 0;\n            if (!nodeColor || !parentColor) {\n              reason = axe.commons.color.incompleteData.get('bgColor');\n            } else {\n              reason = 'bgContrast';\n            }\n            axe.commons.color.incompleteData.set('fgColor', reason);\n            this.data({\n              missingData: axe.commons.color.incompleteData.get('fgColor')\n            });\n            axe.commons.color.incompleteData.clear();\n            return undefined;\n          }\n        }\n        return false;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Links can be distinguished from surrounding text in some way other than by color';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Links need to be distinguished from surrounding text in some way other than by color';\n              return out;\n            }",
            "incomplete": {
              "bgContrast": "Element's contrast ratio could not be determined. Check for a distinct hover/focus style",
              "bgImage": "Element's contrast ratio could not be determined due to a background image",
              "bgGradient": "Element's contrast ratio could not be determined due to a background gradient",
              "imgNode": "Element's contrast ratio could not be determined because element contains an image node",
              "bgOverlap": "Element's contrast ratio could not be determined because of element overlap",
              "default": "Unable to determine contrast ratio"
            }
          }
        }
      },
      {
        "id": "only-listitems",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var dom = axe.commons.dom;\n        var getIsListItemRole = function getIsListItemRole(role, tagName) {\n          return role === 'listitem' || tagName === 'LI' && !role;\n        };\n        var getHasListItem = function getHasListItem(hasListItem, tagName, isListItemRole) {\n          return hasListItem || tagName === 'LI' && isListItemRole || isListItemRole;\n        };\n        var base = {\n          badNodes: [],\n          isEmpty: true,\n          hasNonEmptyTextNode: false,\n          hasListItem: false,\n          liItemsWithRole: 0\n        };\n        var out = virtualNode.children.reduce(function(out, _ref4) {\n          var actualNode = _ref4.actualNode;\n          var tagName = actualNode.nodeName.toUpperCase();\n          if (actualNode.nodeType === 1 && dom.isVisible(actualNode, true, false)) {\n            var role = (actualNode.getAttribute('role') || '').toLowerCase();\n            var isListItemRole = getIsListItemRole(role, tagName);\n            out.hasListItem = getHasListItem(out.hasListItem, tagName, isListItemRole);\n            if (isListItemRole) {\n              out.isEmpty = false;\n            }\n            if (tagName === 'LI' && !isListItemRole) {\n              out.liItemsWithRole++;\n            }\n            if (tagName !== 'LI' && !isListItemRole) {\n              out.badNodes.push(actualNode);\n            }\n          }\n          if (actualNode.nodeType === 3) {\n            if (actualNode.nodeValue.trim() !== '') {\n              out.hasNonEmptyTextNode = true;\n            }\n          }\n          return out;\n        }, base);\n        var virtualNodeChildrenOfTypeLi = virtualNode.children.filter(function(_ref5) {\n          var actualNode = _ref5.actualNode;\n          return actualNode.nodeName.toUpperCase() === 'LI';\n        });\n        var allLiItemsHaveRole = out.liItemsWithRole > 0 && virtualNodeChildrenOfTypeLi.length === out.liItemsWithRole;\n        if (out.badNodes.length) {\n          this.relatedNodes(out.badNodes);\n        }\n        var isInvalidListItem = !(out.hasListItem || out.isEmpty && !allLiItemsHaveRole);\n        return isInvalidListItem || !!out.badNodes.length || out.hasNonEmptyTextNode;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'List element only has direct children that are allowed inside <li> elements';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'List element has direct children that are not allowed inside <li> elements';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "listitem",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var parent = axe.commons.dom.getComposedParent(node);\n        if (!parent) {\n          return undefined;\n        }\n        var parentTagName = parent.nodeName.toUpperCase();\n        var parentRole = (parent.getAttribute('role') || '').toLowerCase();\n        if (parentRole === 'list') {\n          return true;\n        }\n        if (parentRole && axe.commons.aria.isValidRole(parentRole)) {\n          return false;\n        }\n        return [ 'UL', 'OL' ].includes(parentTagName);\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'List item has a <ul>, <ol> or role=\"list\" parent element';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'List item does not have a <ul>, <ol> or role=\"list\" parent element';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "meta-refresh",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var content = node.getAttribute('content') || '', parsedParams = content.split(/[;,]/);\n        return content === '' || parsedParams[0] === '0';\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = '<meta> tag does not immediately refresh the page';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = '<meta> tag forces timed refresh of page';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "meta-viewport-large",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = options || {};\n        var params, content = node.getAttribute('content') || '', parsedParams = content.split(/[;,]/), result = {}, minimum = options.scaleMinimum || 2, lowerBound = options.lowerBound || false;\n        for (var i = 0, l = parsedParams.length; i < l; i++) {\n          params = parsedParams[i].split('=');\n          var key = params.shift().toLowerCase();\n          if (key && params.length) {\n            result[key.trim()] = params.shift().trim().toLowerCase();\n          }\n        }\n        if (lowerBound && result['maximum-scale'] && parseFloat(result['maximum-scale']) < lowerBound) {\n          return true;\n        }\n        if (!lowerBound && result['user-scalable'] === 'no') {\n          this.data('user-scalable=no');\n          return false;\n        }\n        if (result['maximum-scale'] && parseFloat(result['maximum-scale']) < minimum) {\n          this.data('maximum-scale');\n          return false;\n        }\n        return true;\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = '<meta> tag does not prevent significant zooming on mobile devices';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = '<meta> tag limits zooming on mobile devices';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "meta-viewport",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = options || {};\n        var params, content = node.getAttribute('content') || '', parsedParams = content.split(/[;,]/), result = {}, minimum = options.scaleMinimum || 2, lowerBound = options.lowerBound || false;\n        for (var i = 0, l = parsedParams.length; i < l; i++) {\n          params = parsedParams[i].split('=');\n          var key = params.shift().toLowerCase();\n          if (key && params.length) {\n            result[key.trim()] = params.shift().trim().toLowerCase();\n          }\n        }\n        if (lowerBound && result['maximum-scale'] && parseFloat(result['maximum-scale']) < lowerBound) {\n          return true;\n        }\n        if (!lowerBound && result['user-scalable'] === 'no') {\n          this.data('user-scalable=no');\n          return false;\n        }\n        if (result['maximum-scale'] && parseFloat(result['maximum-scale']) < minimum) {\n          this.data('maximum-scale');\n          return false;\n        }\n        return true;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = '<meta> tag does not disable zooming on mobile devices';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = '' + it.data + ' on <meta> tag disables zooming on mobile devices';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "p-as-heading",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var siblings = Array.from(node.parentNode.children);\n        var currentIndex = siblings.indexOf(node);\n        options = options || {};\n        var margins = options.margins || [];\n        var nextSibling = siblings.slice(currentIndex + 1).find(function(elm) {\n          return elm.nodeName.toUpperCase() === 'P';\n        });\n        var prevSibling = siblings.slice(0, currentIndex).reverse().find(function(elm) {\n          return elm.nodeName.toUpperCase() === 'P';\n        });\n        function getTextContainer(elm) {\n          var nextNode = elm;\n          var outerText = elm.textContent.trim();\n          var innerText = outerText;\n          while (innerText === outerText && nextNode !== undefined) {\n            var i = -1;\n            elm = nextNode;\n            if (elm.children.length === 0) {\n              return elm;\n            }\n            do {\n              i++;\n              innerText = elm.children[i].textContent.trim();\n            } while (innerText === '' && i + 1 < elm.children.length);\n            nextNode = elm.children[i];\n          }\n          return elm;\n        }\n        function normalizeFontWeight(weight) {\n          switch (weight) {\n           case 'lighter':\n            return 100;\n\n           case 'normal':\n            return 400;\n\n           case 'bold':\n            return 700;\n\n           case 'bolder':\n            return 900;\n          }\n          weight = parseInt(weight);\n          return !isNaN(weight) ? weight : 400;\n        }\n        function getStyleValues(node) {\n          var style = window.getComputedStyle(getTextContainer(node));\n          return {\n            fontWeight: normalizeFontWeight(style.getPropertyValue('font-weight')),\n            fontSize: parseInt(style.getPropertyValue('font-size')),\n            isItalic: style.getPropertyValue('font-style') === 'italic'\n          };\n        }\n        function isHeaderStyle(styleA, styleB, margins) {\n          return margins.reduce(function(out, margin) {\n            return out || (!margin.size || styleA.fontSize / margin.size > styleB.fontSize) && (!margin.weight || styleA.fontWeight - margin.weight > styleB.fontWeight) && (!margin.italic || styleA.isItalic && !styleB.isItalic);\n          }, false);\n        }\n        var currStyle = getStyleValues(node);\n        var nextStyle = nextSibling ? getStyleValues(nextSibling) : null;\n        var prevStyle = prevSibling ? getStyleValues(prevSibling) : null;\n        if (!nextStyle || !isHeaderStyle(currStyle, nextStyle, margins)) {\n          return true;\n        }\n        var blockquote = axe.commons.dom.findUpVirtual(virtualNode, 'blockquote');\n        if (blockquote && blockquote.nodeName.toUpperCase() === 'BLOCKQUOTE') {\n          return undefined;\n        }\n        if (prevStyle && !isHeaderStyle(currStyle, prevStyle, margins)) {\n          return undefined;\n        }\n        return false;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = '<p> elements are not styled as headings';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Heading elements should be used instead of styled p elements';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "page-has-heading-one",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!options || !options.selector || typeof options.selector !== 'string') {\n          throw new TypeError('visible-in-page requires options.selector to be a string');\n        }\n        var matchingElms = axe.utils.querySelectorAll(virtualNode, options.selector);\n        this.relatedNodes(matchingElms.map(function(vNode) {\n          return vNode.actualNode;\n        }));\n        return matchingElms.length > 0;\n      }",
        "after": "function after(results, options) {\n        var elmUsedAnywhere = results.some(function(frameResult) {\n          return frameResult.result === true;\n        });\n        if (elmUsedAnywhere) {\n          results.forEach(function(result) {\n            result.result = true;\n          });\n        }\n        return results;\n      }",
        "metadata": {
          "impact": "moderate",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Page has at least one level-one heading';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Page must have a level-one heading';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "region",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons7 = axe.commons, dom = _axe$commons7.dom, aria = _axe$commons7.aria;\n        function getSkiplink(virtualNode) {\n          var firstLink = axe.utils.querySelectorAll(virtualNode, 'a[href]')[0];\n          if (firstLink && axe.commons.dom.getElementByReference(firstLink.actualNode, 'href')) {\n            return firstLink.actualNode;\n          }\n        }\n        var skipLink = getSkiplink(virtualNode);\n        var landmarkRoles = aria.getRolesByType('landmark');\n        var implicitLandmarks = landmarkRoles.reduce(function(arr, role) {\n          return arr.concat(aria.implicitNodes(role));\n        }, []).filter(function(r) {\n          return r !== null;\n        });\n        function isSkipLink(vNode) {\n          return skipLink && skipLink === vNode.actualNode;\n        }\n        function isRegion(virtualNode) {\n          var node = virtualNode.actualNode;\n          var explicitRole = axe.commons.aria.getRole(node, {\n            noImplicit: true\n          });\n          var ariaLive = (node.getAttribute('aria-live') || '').toLowerCase().trim();\n          if (explicitRole) {\n            return explicitRole === 'dialog' || landmarkRoles.includes(explicitRole);\n          }\n          if ([ 'assertive', 'polite' ].includes(ariaLive)) {\n            return true;\n          }\n          return implicitLandmarks.some(function(implicitSelector) {\n            var matches = axe.utils.matchesSelector(node, implicitSelector);\n            if (node.tagName.toLowerCase() === 'form') {\n              var titleAttr = node.getAttribute('title');\n              var title = titleAttr && titleAttr.trim() !== '' ? axe.commons.text.sanitize(titleAttr) : null;\n              return matches && (!!aria.labelVirtual(virtualNode) || !!title);\n            }\n            return matches;\n          });\n        }\n        function findRegionlessElms(virtualNode) {\n          var node = virtualNode.actualNode;\n          if (isRegion(virtualNode) || isSkipLink(virtualNode) || !dom.isVisible(node, true)) {\n            return [];\n          } else if (dom.hasContent(node, true)) {\n            return [ node ];\n          } else {\n            return virtualNode.children.filter(function(_ref10) {\n              var actualNode = _ref10.actualNode;\n              return actualNode.nodeType === 1;\n            }).map(findRegionlessElms).reduce(function(a, b) {\n              return a.concat(b);\n            }, []);\n          }\n        }\n        var regionlessNodes = findRegionlessElms(virtualNode);\n        this.relatedNodes(regionlessNodes);\n        return regionlessNodes.length === 0;\n      }",
        "after": "function after(results, options) {\n        return [ results[0] ];\n      }",
        "metadata": {
          "impact": "moderate",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'All page content is contained by landmarks';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Some page content is not contained by landmarks';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "html5-scope",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!axe.commons.dom.isHTML5(document)) {\n          return true;\n        }\n        return node.nodeName.toUpperCase() === 'TH';\n      }",
        "metadata": {
          "impact": "moderate",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Scope attribute is only used on table header elements (<th>)';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'In HTML 5, scope attributes may only be used on table header elements (<th>)';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "scope-value",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = options || {};\n        var value = node.getAttribute('scope').toLowerCase();\n        var validVals = [ 'row', 'col', 'rowgroup', 'colgroup' ] || options.values;\n        return validVals.indexOf(value) !== -1;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Scope attribute is used correctly';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'The value of the scope attribute may only be \\'row\\' or \\'col\\'';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "exists",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return true;\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element does not exist';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element exists';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "skip-link",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var target = axe.commons.dom.getElementByReference(node, 'href');\n        if (target) {\n          return axe.commons.dom.isVisible(target, true) || undefined;\n        }\n        return false;\n      }",
        "metadata": {
          "impact": "moderate",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Skip link target exists';\n              return out;\n            }",
            "incomplete": "function anonymous(it) {\n              var out = 'Skip link target should become visible on activation';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'No skip link target';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "tabindex",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return node.tabIndex <= 0;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Element does not have a tabindex greater than 0';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Element has a tabindex greater than 0';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "same-caption-summary",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return !!(node.summary && node.caption) && node.summary.toLowerCase() === axe.commons.text.accessibleText(node.caption).toLowerCase();\n      }",
        "metadata": {
          "impact": "minor",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'Content of summary attribute and <caption> are not duplicated';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Content of summary attribute and <caption> element are identical';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "caption-faked",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var table = axe.commons.table.toGrid(node);\n        var firstRow = table[0];\n        if (table.length <= 1 || firstRow.length <= 1 || node.rows.length <= 1) {\n          return true;\n        }\n        return firstRow.reduce(function(out, curr, i) {\n          return out || curr !== firstRow[i + 1] && firstRow[i + 1] !== undefined;\n        }, false);\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'The first row of a table is not used as a caption';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'The first row of the table should be a caption instead of a table cell';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "td-has-header",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tableUtils = axe.commons.table;\n        var badCells = [];\n        var cells = tableUtils.getAllCells(node);\n        cells.forEach(function(cell) {\n          if (axe.commons.dom.hasContent(cell) && tableUtils.isDataCell(cell) && !axe.commons.aria.label(cell)) {\n            var hasHeaders = tableUtils.getHeaders(cell).some(function(header) {\n              return header !== null && !!axe.commons.dom.hasContent(header);\n            });\n            if (!hasHeaders) {\n              badCells.push(cell);\n            }\n          }\n        });\n        if (badCells.length) {\n          this.relatedNodes(badCells);\n          return false;\n        }\n        return true;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'All non-empty data cells have table headers';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Some non-empty data cells do not have table headers';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "td-headers-attr",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var cells = [];\n        for (var rowIndex = 0, rowLength = node.rows.length; rowIndex < rowLength; rowIndex++) {\n          var row = node.rows[rowIndex];\n          for (var cellIndex = 0, cellLength = row.cells.length; cellIndex < cellLength; cellIndex++) {\n            cells.push(row.cells[cellIndex]);\n          }\n        }\n        var ids = cells.reduce(function(ids, cell) {\n          if (cell.getAttribute('id')) {\n            ids.push(cell.getAttribute('id'));\n          }\n          return ids;\n        }, []);\n        var badCells = cells.reduce(function(badCells, cell) {\n          var isSelf, notOfTable;\n          var headers = (cell.getAttribute('headers') || '').split(/\\s/).reduce(function(headers, header) {\n            header = header.trim();\n            if (header) {\n              headers.push(header);\n            }\n            return headers;\n          }, []);\n          if (headers.length !== 0) {\n            if (cell.getAttribute('id')) {\n              isSelf = headers.indexOf(cell.getAttribute('id').trim()) !== -1;\n            }\n            notOfTable = headers.reduce(function(fail, header) {\n              return fail || ids.indexOf(header) === -1;\n            }, false);\n            if (isSelf || notOfTable) {\n              badCells.push(cell);\n            }\n          }\n          return badCells;\n        }, []);\n        if (badCells.length > 0) {\n          this.relatedNodes(badCells);\n          return false;\n        } else {\n          return true;\n        }\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'The headers attribute is exclusively used to refer to other cells in the table';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'The headers attribute is not exclusively used to refer to other cells in the table';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "th-has-data-cells",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tableUtils = axe.commons.table;\n        var cells = tableUtils.getAllCells(node);\n        var checkResult = this;\n        var reffedHeaders = [];\n        cells.forEach(function(cell) {\n          var headers = cell.getAttribute('headers');\n          if (headers) {\n            reffedHeaders = reffedHeaders.concat(headers.split(/\\s+/));\n          }\n          var ariaLabel = cell.getAttribute('aria-labelledby');\n          if (ariaLabel) {\n            reffedHeaders = reffedHeaders.concat(ariaLabel.split(/\\s+/));\n          }\n        });\n        var headers = cells.filter(function(cell) {\n          if (axe.commons.text.sanitize(cell.textContent) === '') {\n            return false;\n          }\n          return cell.nodeName.toUpperCase() === 'TH' || [ 'rowheader', 'columnheader' ].indexOf(cell.getAttribute('role')) !== -1;\n        });\n        var tableGrid = tableUtils.toGrid(node);\n        var out = headers.reduce(function(res, header) {\n          if (header.getAttribute('id') && reffedHeaders.includes(header.getAttribute('id'))) {\n            return !res ? res : true;\n          }\n          var hasCell = false;\n          var pos = tableUtils.getCellPosition(header, tableGrid);\n          if (tableUtils.isColumnHeader(header)) {\n            hasCell = tableUtils.traverse('down', pos, tableGrid).reduce(function(out, cell) {\n              return out || axe.commons.dom.hasContent(cell) && !tableUtils.isColumnHeader(cell);\n            }, false);\n          }\n          if (!hasCell && tableUtils.isRowHeader(header)) {\n            hasCell = tableUtils.traverse('right', pos, tableGrid).reduce(function(out, cell) {\n              return out || axe.commons.dom.hasContent(cell) && !tableUtils.isRowHeader(cell);\n            }, false);\n          }\n          if (!hasCell) {\n            checkResult.relatedNodes(header);\n          }\n          return res && hasCell;\n        }, true);\n        return out ? true : undefined;\n      }",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'All table header cells refer to data cells';\n              return out;\n            }",
            "fail": "function anonymous(it) {\n              var out = 'Not all table header cells refer to data cells';\n              return out;\n            }",
            "incomplete": "function anonymous(it) {\n              var out = 'Table data cells are missing or empty';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "description",
        "enabled": true,
        "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tracks = axe.utils.querySelectorAll(virtualNode, 'track');\n        var hasDescriptions = tracks.some(function(_ref7) {\n          var actualNode = _ref7.actualNode;\n          return (actualNode.getAttribute('kind') || '').toLowerCase() === 'descriptions';\n        });\n        return hasDescriptions ? false : undefined;\n      }",
        "metadata": {
          "impact": "critical",
          "messages": {
            "pass": "function anonymous(it) {\n              var out = 'The multimedia element has an audio description track';\n              return out;\n            }",
            "incomplete": "function anonymous(it) {\n              var out = 'Check that audio description is available for the element';\n              return out;\n            }"
          }
        }
      },
      {
        "id": "anchor-page-link-button",
        "evaluate": "function evaluate(node, options, virtualNode, context) {\nconst href = node.getAttribute(\"href\");\nconst isPageAnchor = href.charAt(0) === \"#\" ? true : false;\n\nif (!isPageAnchor) {\n  return true;\n}\n\nconst triggers = [\n  \"aria-haspopup\",\n  \"aria-expanded\"\n];\n\nconst isAnchorButton = triggers.some((trigger) => node.hasAttribute(trigger));\n\nreturn isAnchorButton ? false : undefined;\n}\n",
        "metadata": {
          "impact": "serious",
          "messages": {
            "pass": "Nicely done",
            "fail": "This link looks like it's doing something rather than going somewhere. A button should be used instead.",
            "incomplete": "We can't be sure this is bad, so you should check manually."
          }
        },
        "enabled": true
      },
      {
        "id": "caption",
        "evaluate": "function evaluate(node, options, virtualNode, context) {\nconst tracks = axe.utils.querySelectorAll(virtualNode, 'track');\nconst hasCaptions = tracks.some(\n\t({ actualNode }) =>\n\t\t(actualNode.getAttribute('kind') || '').toLowerCase() === 'captions'\n);\n\nreturn hasCaptions ? false : true;\n}\n",
        "enabled": true
      },
      {
        "id": "description",
        "evaluate": "function evaluate(node, options, virtualNode, context) {\nconst tracks = axe.utils.querySelectorAll(virtualNode, 'track');\nconst hasDescriptions = tracks.some(\n\t({ actualNode }) =>\n\t\t(actualNode.getAttribute('kind') || '').toLowerCase() === 'descriptions'\n);\n\nreturn hasDescriptions ? false : true;\n}\n",
        "enabled": true
      }
    ],
    "disableOtherRules": true,
    "ver": "3.1.2"
  }